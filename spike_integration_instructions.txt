INSTRUCTIONS POUR INT√âGRER LES FONCTIONS SPIKE DANS F_INX_Scalper_double.mq5

======================================================================
ERREUR ACTUELLE: function 'DetectBoomCrashSpike' must have a body
======================================================================

SOLUTION: Copiez-collez les fonctions suivantes dans votre fichier F_INX_Scalper_double.mq5

EMPLACEMENT RECOMMAND√â: Juste apr√®s la ligne 11851 (apr√®s "return false;}" de la fonction DetectBoomCrashSpikeOpportunity)

FONCTIONS √Ä COPIER:

//+------------------------------------------------------------------+
//| FONCTIONS POUR LA D√âTECTION DES SPIKES BOOM/CRASH               |
//+------------------------------------------------------------------+

//+------------------------------------------------------------------+
//| D√©tecter un spike Boom/Crash en temps r√©el                       |
//+------------------------------------------------------------------+
bool DetectBoomCrashSpike()
{
   // V√©rifier si c'est un symbole Boom/Crash
   if(!IsBoomCrashSymbol(_Symbol))
      return false;
   
   // Obtenir les prix actuels
   double bid = SymbolInfoDouble(_Symbol, SYMBOL_BID);
   double ask = SymbolInfoDouble(_Symbol, SYMBOL_ASK);
   double currentPrice = (bid + ask) / 2.0;
   
   // Initialiser le prix de r√©f√©rence
   if(g_lastBoomCrashPrice == 0.0)
   {
      g_lastBoomCrashPrice = currentPrice;
      return false;
   }
   
   // Calculer le mouvement en pourcentage
   double priceChange = MathAbs(currentPrice - g_lastBoomCrashPrice);
   double priceChangePercent = (priceChange / g_lastBoomCrashPrice) * 100.0;
   
   // Seuil de d√©tection de spike (diff√©rent pour Boom et Crash)
   double spikeThreshold = 0.3; // 0.3% de mouvement
   
   // D√©tecter un spike significatif
   if(priceChangePercent >= spikeThreshold)
   {
      // D√©terminer la direction du spike
      ENUM_ORDER_TYPE spikeDirection;
      if(currentPrice > g_lastBoomCrashPrice)
      {
         // Spike haussier -> attendre une correction SELL
         spikeDirection = ORDER_TYPE_SELL;
      }
      else
      {
         // Spike baissier -> attendre une correction BUY
         spikeDirection = ORDER_TYPE_BUY;
      }
      
      // Cr√©er la fl√®che dynamique clignotante
      DrawSpikeArrow(spikeDirection, currentPrice);
      
      // Mettre √† jour le prix de r√©f√©rence
      g_lastBoomCrashPrice = currentPrice;
      
      if(DebugMode)
         Print("üö® SPIKE D√âTECT√â sur ", _Symbol, ": ", DoubleToString(priceChangePercent, 3), "% - Direction: ", EnumToString(spikeDirection));
      
      return true;
   }
   
   // Mettre √† jour le prix de r√©f√©rence progressivement
   g_lastBoomCrashPrice = currentPrice;
   
   return false;
}

//+------------------------------------------------------------------+
//| Dessiner une fl√®che dynamique clignotante pour spike             |
//+------------------------------------------------------------------+
void DrawSpikeArrow(ENUM_ORDER_TYPE orderType, double price)
{
   // Supprimer l'ancienne fl√®che si elle existe
   if(g_spikeArrowName != "")
      ObjectDelete(0, g_spikeArrowName);
   
   // Cr√©er le nom de la fl√®che
   g_spikeArrowName = "SPIKE_ARROW_" + _Symbol + "_" + IntegerToString(TimeCurrent());
   g_spikeArrowTime = TimeCurrent();
   g_spikeOrderType = orderType;
   g_spikeArrowBlinkState = true;
   g_lastBlinkTime = TimeCurrent();
   
   // Cr√©er la fl√®che selon la direction
   int arrowCode = (orderType == ORDER_TYPE_BUY) ? 233 : 234; // 233=fl√®che haut, 234=fl√®che bas
   color arrowColor = (orderType == ORDER_TYPE_BUY) ? clrBlue : clrRed;
   
   if(ObjectCreate(0, g_spikeArrowName, OBJ_ARROW, 0, TimeCurrent(), price))
   {
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_ARROWCODE, arrowCode);
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_COLOR, arrowColor);
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_WIDTH, 5);
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_BACK, false);
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_SELECTABLE, false);
      ObjectSetString(0, g_spikeArrowName, OBJPROP_TEXT, "SPIKE - CLICK FOR LIMIT ORDER");
      ObjectSetInteger(0, g_spikeArrowName, OBJPROP_TIMEFRAMES, OBJ_ALL_PERIODS);
      
      if(DebugMode)
         Print("üéØ Fl√®che de spike cr√©√©e: ", g_spikeArrowName, " √† ", DoubleToString(price, _Digits));
   }
}

//+------------------------------------------------------------------+
//| Mettre √† jour le clignotement de la fl√®che de spike              |
//+------------------------------------------------------------------+
void UpdateSpikeArrowBlink()
{
   // V√©rifier si la fl√®che existe et est r√©cente (moins de 30 secondes)
   if(g_spikeArrowName == "" || (TimeCurrent() - g_spikeArrowTime) > 30)
   {
      // Supprimer la fl√®che si elle est trop vieille
      if(g_spikeArrowName != "")
      {
         ObjectDelete(0, g_spikeArrowName);
         g_spikeArrowName = "";
      }
      return;
   }
   
   // Clignoter toutes les 500ms
   if((TimeCurrent() - g_lastBlinkTime) >= 0.5)
   {
      g_spikeArrowBlinkState = !g_spikeArrowBlinkState;
      g_lastBlinkTime = TimeCurrent();
      
      // Changer la visibilit√© ou la couleur pour l'effet de clignotement
      if(ObjectFind(0, g_spikeArrowName) >= 0)
      {
         if(g_spikeArrowBlinkState)
         {
            // √âtat visible - couleur vive
            color arrowColor = (g_spikeOrderType == ORDER_TYPE_BUY) ? clrBlue : clrRed;
            ObjectSetInteger(0, g_spikeArrowName, OBJPROP_COLOR, arrowColor);
            ObjectSetInteger(0, g_spikeArrowName, OBJPROP_WIDTH, 5);
         }
         else
         {
            // √âtat clignot√© - couleur plus p√¢le
            color arrowColor = (g_spikeOrderType == ORDER_TYPE_BUY) ? clrDodgerBlue : clrIndianRed;
            ObjectSetInteger(0, g_spikeArrowName, OBJPROP_COLOR, arrowColor);
            ObjectSetInteger(0, g_spikeArrowName, OBJPROP_WIDTH, 3);
         }
      }
   }
}

//+------------------------------------------------------------------+
//| Placer un ordre limite lors d'un spike                           |
//+------------------------------------------------------------------+
void PlaceLimitOrderOnSpike(ENUM_ORDER_TYPE orderType, double spikePrice)
{
   // Calculer le prix d'entr√©e pour l'ordre limite
   double entryPrice;
   double sl, tp;
   
   if(orderType == ORDER_TYPE_BUY)
   {
      // Spike baissier -> ordre limite BUY en dessous du prix actuel
      entryPrice = spikePrice * 0.998; // 0.2% en dessous du spike
      sl = entryPrice - (StopLossUSD / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
      tp = entryPrice + (TakeProfitUSD / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
   }
   else // ORDER_TYPE_SELL
   {
      // Spike haussier -> ordre limite SELL au-dessus du prix actuel
      entryPrice = spikePrice * 1.002; // 0.2% au-dessus du spike
      sl = entryPrice + (StopLossUSD / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
      tp = entryPrice - (TakeProfitUSD / SymbolInfoDouble(_Symbol, SYMBOL_TRADE_TICK_VALUE));
   }
   
   // Normaliser les prix
   entryPrice = NormalizeDouble(entryPrice, _Digits);
   sl = NormalizeDouble(sl, _Digits);
   tp = NormalizeDouble(tp, _Digits);
   
   // Placer l'ordre limite
   trade.SetExpertMagicNumber(InpMagicNumber);
   
   bool success = false;
   if(orderType == ORDER_TYPE_BUY)
   {
      success = trade.BuyLimit(InitialLotSize, _Symbol, entryPrice, sl, tp, "Spike BUY Limit");
   }
   else
   {
      success = trade.SellLimit(InitialLotSize, _Symbol, entryPrice, sl, tp, "Spike SELL Limit");
   }
   
   if(success)
   {
      Print("‚úÖ Ordre limite SPIKE plac√©: ", EnumToString(orderType), " √† ", DoubleToString(entryPrice, _Digits));
      Print("   SL: ", DoubleToString(sl, _Digits), " | TP: ", DoubleToString(tp, _Digits));
      
      // Supprimer la fl√®che apr√®s avoir plac√© l'ordre
      if(g_spikeArrowName != "")
      {
         ObjectDelete(0, g_spikeArrowName);
         g_spikeArrowName = "";
      }
   }
   else
   {
      Print("‚ùå √âchec ordre limite SPIKE: ", trade.ResultRetcode(), " - ", trade.ResultRetcodeDescription());
   }
}

======================================================================
V√âRIFICATION: Apr√®s avoir copi√© ces fonctions, le fichier devrait compiler sans erreur.
======================================================================
