
FINXscalperdoublemq5
Copyright2025MetaQuotesLtd
https:wwwmetaquotesnet

propertycopyrightCopyright2025MetaQuotesLtd
propertylinkhttps:wwwmetaquotesnet
propertyversion100
propertystrict

Constantesmanquantespourlacompatibilit
ifndefANCHORLEFTUPPER
defineANCHORLEFTUPPER0
endif
ifndefANCHORLEFT
defineANCHORLEFT0
endif

InclusionsdesbibliothquesWindowsncessaires
include<WinAPI\errhandlingapimqh>
include<WinAPI\sysinfoapimqh>
include<WinAPI\processenvmqh>
include<WinAPI\libloaderapimqh>
include<WinAPI\memoryapimqh>

include<TradeTrademqh>
include<TradePositionInfomqh>
include<TradeOrderInfomqh>
include<TradeDealInfomqh>
include<TradeHistoryOrderInfomqh>
include<TradeTerminalInfomqh>


Paramtresdentre

inputgroupCONFIGURATIONDEBASE
inputintInpMagicNumber=888888;MagicNumber
inputdoubleInitialLotSize=001;Tailledelotinitiale
inputdoubleMaxLotSize=10;Tailledelotmaximale
inputdoubleTakeProfitUSD=150;TakeProfitenUSDfixeaugmentde50points
inputdoubleStopLossUSD=80;StopLossenUSDfixeaugmentde30points
inputdoubleMaxLossPerPosition=50;PertemaximaleparpositionUSDmaintenu5
inputdoubleProfitThresholdForDouble=05;SeuildeprofitUSDpourdoublerlelot
inputintMinPositionLifetimeSec=5;Dlaiminimumavantmodificationsecondes

inputgroupOPTIMISATIONPERFORMANCE
inputboolHighPerformanceMode=true;ModehauteperformancerduitchargeCPU
inputintPositionCheckInterval=10;Intervallevrificationpositionssecondes
inputintGraphicsUpdateInterval=120;Intervallemisejourgraphiquessecondes
inputboolDisableAllGraphics=false;Dsactivertouslesgraphiquesperformancemaximale
inputboolShowInfoOnChart=false;AfficherlesinfosIAdirectementsurlegraphique
inputboolDisableNotifications=false;Dsactiverlesnotificationsperformance

inputgroupAIAGENT
inputboolUseAIAgent=true;ActiverlagentIAviaserveurexterne
inputstringAIServerURL=https:kolatradebotonrendercomdecision;URLserveurIA
inputboolUseAdvancedDecisionGemma=false;UtiliserendpointdecisionGemmaGemmaGeminiavecanalysevisuelle
inputintAITimeoutms=800;TimeoutWebRequestenmillisecondes
inputdoubleAIMinConfidence=600;ConfianceminimaleIApourtrader60ajustaveccalculintelligent
NOTE:LeserveurIAgarantitmaintenant60minimumsiH1align70siH1H4D1
PourBoomCrashleseuilestautomatiquementabaiss45danslecode
pourlestendancesfortesH4D1alignsLeserveurajouteautomatiquement
desbonus25pourH4D1aligns1020pouralignementmultiTF
inputintAIUpdateInterval=5;IntervalledemisejourIAsecondes
inputintAIAnalysisIntervalSec=60;Frquencederafrachissementdelanalysesecondes
inputstringAITimeWindowsURLBase=https:kolatradebotonrendercom;RacineAPIpourtimewindows
inputstringAIAnalysisURL=https:kolatradebotonrendercomanalysis;
inputstringTrendAPIURL=https:kolatradebotonrendercomtrend;
inputstringAIPredictSymbolURL=https:kolatradebotonrendercompredict;
inputstringAICoherentAnalysisURL=https:kolatradebotonrendercomcoherentanalysis;
inputstringAIMLPredictURL=https:kolatradebotonrendercommlpredict;
inputboolUseAllEndpoints=true;
inputdoubleMinEndpointsConfidence=300;

inputgroupTABLEAUDEBORDIA
inputboolShowDashboard=true;Afficherletableaudebord
inputcolorDashboardBGColor=clrBlack;Couleurdefonddudashboard
inputcolorTextColor=clrWhite;Couleurdutexte

inputgroupINTEGRATIONIAAVANCE
inputboolUseAdvancedValidation=true;ActivervalidationmulticouchespourlestradesIA
inputboolRequireAllEndpointsAlignment=false;ExigeralignementdeTOUSlesendpointsIAavanttrading
inputdoubleMinAllEndpointsConfidence=700;Confianceminimalepouralignementdetouslesendpoints
inputboolUseDynamicTPCalculation=true;CalculerTPdynamiqueauprochainSupportRsistance
inputboolUseImmediatePredictionCheck=true;Vrifierdirectionimmdiatedelaprdictionavanttrade
inputboolUseStrongReversalValidation=true;ExigerretournementfrancaprstoucheEMASupportRsistance

inputgroupEXECUTIONSEUILSRECOMMAND
inputboolAllowTradingWhenNotificationsDisabled=true;Sitrue:dsactivernotifsnebloqueplusletrading
inputdoubleAIMinConfidenceDefault=650;SeuilpardfauthorsBoomCrashVolatilityForex
inputdoubleAIMinConfidenceVolatility=550;DerivVolatilityIndicessynthtiques:seuilrecommand
inputdoubleAIMinConfidenceForex=700;Forex:seuilpluslev
inputdoubleAIMinConfidenceCautious=800;Modeprudentpertequotidienneleve
inputdoubleAIMarketExecutionConfidence=920;Sisignaltrsfort:excutionmarchpossiblehorsBoomCrash
inputintLimitEntryOffsetPoints=5;BUYLIMITaudessussupportSELLLIMITsousrsistance
inputintLimitSLOffsetPoints=10;SLsoussupportaudessusrsistance
inputdoubleLimitRR=20;TP=RRrisque

inputgroupVISUELPRDICTIONSPLUSRALISTE
inputboolUseHistoricalCandleProfile=true;Bougiesfuturescalquessurlhistoriquercent
inputintCandleProfileLookback=120;NombredebougieshistoriquespourcalibrerTFcourant
inputdoublePredictionMaxDriftATR=12;DriftmaxenATRsurlhorizondessin

inputgroupLMENTSGRAPHIQUES
inputboolDrawAIZones=true;DessinerleszonesBUYSELLdelIA
inputboolDrawSupportResistance=true;DessinersupportrsistanceM5H1
inputboolDrawTrendlines=true;Dessinerlestrendlines
inputboolDrawDerivPatterns=true;DessinerlespatternsDeriv
inputboolDrawSMCZones=false;DessinerleszonesSMCOrderBlockDSACTIVpourperformance

inputgroupSTRATGIEUSSESSIONBREAKRETESTPRIORITAIRE
inputboolUseUSSessionStrategy=false;ActiverlastratgieUSSessionprioritaireDSACTIVpourpermettretradingnormal
inputdoubleUSRiskReward=20;RiskRewardratiopourUSSession
inputintUSRetestTolerance=30;Tolranceretestenpoints
inputboolUSOneTradePerDay=true;UnseultradeparjourpourUSSession

inputgroupGESTIONDESRISQUES
inputdoubleMaxDailyLoss=1000;PertequotidiennemaximaleUSD
inputdoubleMaxDailyProfit=2000;ProfitquotidienmaximaleUSD
inputdoubleMaxTotalLoss=50;PertetotalemaximaletoutespositionsUSD
inputboolUseTrailingStop=true;Utilisertrailingstopdsactivpourscalpingfixe

inputgroupSORTIESVOLATILITY
inputdoubleVolatilityQuickTP=20;FermerrapidementlesindicesVolatility2deprofit

inputgroupSORTIESBOOMCRASH
inputdoubleBoomCrashSpikeTP=001;FermerBoomCrashdsquelespikedonneaumoinsceprofit001=quasiimmdiat

inputgroupINDICATEURS
inputintEMAFastPeriod=9;PriodeEMArapide
inputintEMASlowPeriod=21;PriodeEMAlente
inputintRSIPeriod=14;PriodeRSI
inputintATRPeriod=14;PriodeATR
inputboolShowLongTrendEMA=true;AfficherEMA50100200surlegraphiquecourbes
inputboolUseTrendAPIAnalysis=true;UtiliserlanalysedetendanceAPIpouraffinerlesdcisions
inputdoubleTrendAPIMinConfidence=700;ConfianceminimumAPIpourvalidation70

inputgroupDEBUG
inputboolDebugMode=true;Modedebuglogsdtaills


Variablesglobales

CTradetrade;
CPositionInfopositionInfo;
COrderInfoorderInfo;
CDealInfodealInfo;

Handlesdesindicateurs
intemaFastHandle;
intemaSlowHandle;
intemaFastH1Handle;
intemaSlowH1Handle;
intemaFastM5Handle;
intemaSlowM5Handle;
EMApourtendanceslongues50100200
intema50Handle;
intema100Handle;
intema200Handle;
intrsiHandle;
intatrHandle;
intatrM5Handle;
intatrH1Handle;
intatrM1Handle;

VariablespourlesendpointsRender
staticstringglastAnalysisData=;
staticstringglastTrendData=;
staticstringglastPredictionData=;
staticstringglastCoherentData=;
staticdoublegendpointsAlignment=00;
staticdatetimeglastEndpointUpdate=0;
staticintglastAISource=0;0=Local1=Render

Variablespourletableaudebord
stringgdashboardName=AITradingDashboard;
stringgalignmentStatus[4;Statutdechaqueendpoint
colorgalignmentColors[4;Couleurspourchaqueindicateur
stringgendpointNames[4=AnalyseTrendPredictionCoherent;

VariablesIA
staticstringglastAIAction=;
staticdoubleglastAIConfidence=00;
staticstringglastAIReason=;
staticdatetimeglastAITime=0;

Helpersdexcutionseuils
boolIsDerivSyntheticIndexconststringsymbol;
ENUMORDERTYPEGetPendingTypeFromSignalconstENUMORDERTYPEsignalType;

Variablespoursuivrelesordresdjexcutsantidoublon
staticstringgexecutedOrdersSymbols=;Listedessymbolesavecordresdjexcuts
staticdatetimeglastOrderExecutionTime=0;
staticboolgaiFallbackMode=false;
staticintgaiConsecutiveFailures=0;
constintAIFAILURETHRESHOLD=3;

VariablespourapitrendanalysedetendanceAPI
staticintgapitrenddirection=0;DirectiondetendanceAPI1=BUY1=SELL0=neutre
staticdoublegapitrendstrength=00;ForcedelatendanceAPI0100
staticdoublegapitrendconfidence=00;ConfiancedelatendanceAPI0100
staticdatetimegapitrendlastupdate=0;TimestampdeladerniremisejourAPI
staticstringgapitrendsignal=;SignaldetendanceAPI
staticboolgapitrendvalid=false;LesdonnesAPIsontellesvalides?

ZonesIA
staticdoublegaiBuyZoneLow=00;
staticdoublegaiBuyZoneHigh=00;
staticdoublegaiSellZoneLow=00;
staticdoublegaiSellZoneHigh=00;

Suividespositions
structPositionTracker
ulongticket;
doubleinitialLot;
doublecurrentLot;
doublehighestProfit;
boollotDoubled;
datetimeopenTime;
doublemaxProfitReached;Profitmaximumatteintpourcetteposition
boolprofitSecured;Indiquesileprofitatscuris
doublepartialClosedLot;LotfermpartiellementNOUVEAU
boolbreakevenActivated;BreakevenactivNOUVEAU
;

staticPositionTrackergpositionTracker;
staticboolghasPosition=false;

Suividuprofitglobalpourscurisation
staticdoublegglobalMaxProfit=00;Profitmaximumglobalatteinttoutespositions
constdoublePROFITSECURETHRESHOLD=30;Seuildactivation3
constdoublePROFITDRAWDOWNLIMIT=05;Limitededrawdown50

Tableaupoursuivreleprofitmaxdechaqueposition
structPositionProfitTracker
ulongticket;
doublemaxProfit;
datetimelastUpdate;
;

staticPositionProfitTrackergprofitTrackers[;
staticintgprofitTrackersCount=0;

Suiviquotidien
staticdoublegdailyProfit=00;
staticdoublegdailyLoss=00;
staticdatetimeglastDayReset=0;

SuivipourfermetureaprsspikeBoomCrash
staticdoubleglastBoomCrashPrice=00;Prixderfrencepourdtecterlespike

VariablespourlessortiesrapidesVolatilityetBoomCrash
staticdoublegvolatilityQuickTP=20;SeuilpourfermeturerapideVolatility
staticdoublegboomCrashSpikeTP=001;SeuilpourfermeturerapideBoomCrash

SuividestentativesdespikeetcooldownBoomCrash
staticstringgspikeSymbols[;
staticintgspikeFailCount[;
staticdatetimegspikeCooldown[;

Dclarationsforwarddesfonctions
boolIsVolatilitySymbolconststringsymbol;
boolIsBoomCrashSymbolconststringsym;
boolIsForexSymbolconststringsymbol;
doubleGetTotalLoss;
doubleNormalizeLotSizedoublelot;
voidCleanOldGraphicalObjects;
voidDrawAIConfidenceAndTrendSummary;
voidDrawRenderEndpointsStatus;
voidDrawLongTrendEMA;
voidDeleteEMAObjectsstringprefix;
voidDrawEMACurveOptimizedstringprefixdoublevalues[datetimetimes[intcountcolorclrintwidthintstep;
voidDrawAIZonesOnChart;
voidDrawSupportResistanceLevels;
voidDrawTrendlinesOnChart;
voidDrawSMCZonesOnChart;
voidDeleteSMCZones;
voidDrawPredictionsOnChartstringpredictionData;
voidCheckAndManagePositions;
voidSecureDynamicProfits;
voidSecureProfitForPositionulongticketdoublecurrentProfit;
voidLookForTradingOpportunity;
boolCheckReboundOnTrendlineENUMORDERTYPEorderTypedoubledistance;
boolDetectReversalAtFastEMAENUMORDERTYPEorderType;
boolCheckAIZoneEntryWithEMAENUMORDERTYPEorderTypeboolisInZoneboolemaConfirmedboolisCorrection;
boolCheckTrendAlignmentENUMORDERTYPEorderType;
intCountActiveSymbols;
voidDrawDerivPatternsOnChart;
voidUpdateDerivArrowBlink;
boolDetectDynamicPatternsAndExecute;
voidActivateTrailingStop;
boolPlaceLimitOrderOnArrowENUMORDERTYPEsignalType;
voidDrawFutureCandlesAdaptive;
voidTradeBasedOnFutureCandlesstringdirectiondoubleconfidencedoublecurrentPricedoubleatrValue;
boolParsePredictionDatastringjsonstringdirectiondoubleconfidence;
Nouvellesfonctionsdamlioration
voidDetectAndDisplayCorrections;
voidPartialClosePositionulongticketdoublecurrentProfit;
voidActivateBreakevenulongticketdoublecurrentProfit;


DtectionindicessynthtiquesDeriv

boolIsDerivSyntheticIndexconststringsymbol

Heuristique:laplupartdesindicessynthtiquesDerivincluentVolatilityStepBoomCrash
OnajouteaussilessymbolespersonnalisstypeFINXINX
ifIsVolatilitySymbolsymbol
returntrue;
ifStringFindsymbolIndex=1
returntrue;
ifStringFindsymbolINX=1StringFindsymbolFINX=1
returntrue;
returnfalse;



ConvertitBUYSELLenBUYLIMITSELLLIMIT

ENUMORDERTYPEGetPendingTypeFromSignalconstENUMORDERTYPEsignalType

ifsignalType==ORDERTYPEBUY
returnORDERTYPEBUYLIMIT;
ifsignalType==ORDERTYPESELL
returnORDERTYPESELLLIMIT;
returnWRONGVALUE;



Vrifiersiunordreadjtexcutpourunsymbole
vitelesdoublonsquandlaflcheclignoteplusieursfois

boolHasOrderAlreadyExecutedstringsymbol

Vrifiersilesymboleestdanslalistedesordresdjexcuts
ifStringFindgexecutedOrdersSymbolssymbol;>=0

ifDebugMode
PrintOrdredjexcutpoursymbolantidoublonactiv;
returntrue;

returnfalse;



Marquerunordrecommeexcutpourunsymbole

voidMarkOrderAsExecutedstringsymbol

Ajouterlesymbolelalistedesordresexcuts
gexecutedOrdersSymbols=symbol;;
glastOrderExecutionTime=TimeCurrent;

ifDebugMode
PrintOrdremarqucommeexcutpoursymbol;



Retirerunsymboledelalisteexcuteaprsfermeture
PermetdereprendreuntradeBoomCrashaprsspike

voidRemoveSymbolFromExecutedListstringsymbol

stringneedle=symbol;;
intpos=StringFindgexecutedOrdersSymbolsneedle;
ifpos>=0

gexecutedOrdersSymbols=StringSubstrgexecutedOrdersSymbols0pos
StringSubstrgexecutedOrdersSymbolsposStringLenneedle;
ifDebugMode
PrintSymbolesymbolretirdelalisteprtpournouveautradeBoomCrash;




Rinitialiserlalistedesordresexcutsnouvellesession

voidResetExecutedOrdersList

Rinitialisertoutesles4heuresouauchangementdejourne
datetimecurrentTime=TimeCurrent;
staticdatetimelastReset=0;

MqlDateTimecurrentStructlastStruct;
TimeToStructcurrentTimecurrentStruct;
TimeToStructlastResetlastStruct;

ifcurrentTimelastReset>144004heures
currentStructday=lastStructdayChangementdejourne

gexecutedOrdersSymbols=;
lastReset=currentTime;

ifDebugMode
PrintListedesordresexcutsrinitialise;




ExcuterimmdiatementuntradeBoomCrashaumarch
Utilispourlesspikesavecconfianceleve85

boolExecuteImmediateBoomCrashTradeENUMORDERTYPEsignalType

doublecurrentPrice=SymbolInfoDoubleSymbolsignalType==ORDERTYPEBUY?SYMBOLASK:SYMBOLBID;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

CalculerSLTPrapidespourBoomCrashspikes
doubleatrValue=0;
doubleatrBuffer[1;
ifCopyBufferatrHandle001atrBuffer>0
atrValue=atrBuffer[0;
else
atrValue=currentPrice0001;Fallback01

doublestopLoss=0;
doubletakeProfit=0;

ifsignalType==ORDERTYPEBUY

PourBUYsurBoom:SLserrTPrapide
stopLoss=currentPriceatrValue05;SLtrsserr
takeProfit=currentPriceatrValue15;TPrapide1:3ratio

elseSELLsurCrash

PourSELLsurCrash:SLserrTPrapide
stopLoss=currentPriceatrValue05;SLtrsserr
takeProfit=currentPriceatrValue15;TPrapide1:3ratio


VrifierlesdistancesminimalespourBoomCrash
doubleminDistance=MathMax20pointatrValue02;Minimum20pointsou02ATR
doubleslDistance=MathAbscurrentPricestopLoss;
doubletpDistance=MathAbstakeProfitcurrentPrice;

ifslDistance<minDistancetpDistance<minDistance

ifDebugMode
PrintDistancesSLTPtropfaiblespourBoomCrash:SL=DoubleToStringslDistancepoint0TP=DoubleToStringtpDistancepoint0;
returnfalse;


Tailledepositionadaptelaconfiance
doublelotSize=InitialLotSize;
ifglastAIConfidence>=095
lotSize=InitialLotSize15;Confiancetrsleve
elseifglastAIConfidence>=090
lotSize=InitialLotSize12;Confianceleve

lotSize=NormalizeLotSizelotSize;

Excuterlordreaumarchimmdiatement
stringorderComment=BoomCrashIMMEDIATEEnumToStringsignalTypeconf:DoubleToStringglastAIConfidence1001;

boolsuccess=false;
ifsignalType==ORDERTYPEBUY

success=tradeBuylotSizeSymbolcurrentPricestopLosstakeProfitorderComment;

elseSELL

success=tradeSelllotSizeSymbolcurrentPricestopLosstakeProfitorderComment;


ifsuccess

doubleriskUSD=slDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=tpDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintTRADEBOOMCRASHEXCUTIMMDIATEMENT:;
PrintType:EnumToStringsignalType;
PrintEntre:DoubleToStringcurrentPriceDigits;
PrintSL:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTP:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;
PrintTaille:DoubleToStringlotSize2;
PrintConfiance:DoubleToStringglastAIConfidence1001;
PrintExcution:IMMDIATEspikeBoomCrash;

Envoyernotification
ifDisableNotifications

stringnotificationText=BOOMCRASHIMMDIAT\nSymbolEnumToStringsignalType
\n@DoubleToStringcurrentPriceDigits
\nConfiance:DoubleToStringglastAIConfidence1001;
SendNotificationnotificationText;
AlertnotificationText;


returntrue;

else

PrintErreurexcutionBoomCrash:tradeResultRetcodetradeResultRetcodeDescription;
returnfalse;



FonctionspourlesendpointsRender
voidUpdateAllEndpoints;
stringUpdateAnalysisEndpoint;
stringUpdateTrendEndpoint;
stringUpdatePredictionEndpoint;
stringUpdateCoherentEndpoint;
boolCheckAllEndpointsAlignmentENUMORDERTYPEorderType;

intGetSpikeIndexconststringsym

forinti=0;i<ArraySizegspikeSymbols;i

ifgspikeSymbols[i==sym
returni;

intidx=ArraySizegspikeSymbols;
ArrayResizegspikeSymbolsidx1;
ArrayResizegspikeFailCountidx1;
ArrayResizegspikeCooldownidx1;
gspikeSymbols[idx=sym;
gspikeFailCount[idx=0;
gspikeCooldown[idx=0;
returnidx;


boolIsBoomCrashSymbolconststringsym

returnStringFindsymBoom=1StringFindsymCrash=1;


FermertouteslespositionsVolatilitysilapertetotaledpasseunseuil
voidCloseVolatilityIfLossExceededdoublelossLimit

doubletotalProfitVol=00;
CalculerlePnLcumuldespositionsVolatilitytoussymbolespourceMagic
forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

stringsym=positionInfoSymbol;
ifIsVolatilitySymbolsympositionInfoMagic==InpMagicNumber

totalProfitVol=positionInfoProfit;




SipertecumuledpasseleseuilfermertouteslespositionsVolatility
iftotalProfitVol<=MathAbslossLimit

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

stringsym=positionInfoSymbol;
ifIsVolatilitySymbolsympositionInfoMagic==InpMagicNumber

doublep=positionInfoProfit;
iftradePositionCloseticket

PrintVolatilitypertecumuledpasseDoubleToStringtotalProfitVol2
<=DoubleToStringMathAbslossLimit2Fermetureticket=ticket
sym=symprofit=DoubleToStringp2;

elseifDebugMode

PrintErreurfermetureVolatilityticket=ticketcode=tradeResultRetcode
desc=tradeResultRetcodeDescription;







VariablesUSSessionBreakRetestSTRATGIEPRIORITAIRE
staticdoublegUSHigh=00;HautdurangeUSbougieM515h30
staticdoublegUSLow=00;BasdurangeUSbougieM515h30
staticboolgUSRangeDefined=false;RangeUSdfini
staticboolgUSBreakoutDone=false;Breakoutdtect
staticboolgUSTradeTaken=false;TradeUSprisaujourdhui
staticintgUSDirection=0;1=BUY1=SELL0=neutre
staticdatetimegUSRangeDate=0;Datedurangepourresetquotidien


Expertinitializationfunction

intOnInit

tradeSetExpertMagicNumberInpMagicNumber;
tradeSetDeviationInPoints10;
tradeSetTypeFillingORDERFILLINGFOK;
tradeSetAsyncModefalse;

InitialiserlesindicateursM1
emaFastHandle=iMASymbolPERIODM1EMAFastPeriod0MODEEMAPRICECLOSE;
emaSlowHandle=iMASymbolPERIODM1EMASlowPeriod0MODEEMAPRICECLOSE;
rsiHandle=iRSISymbolPERIODM1RSIPeriodPRICECLOSE;
atrHandle=iATRSymbolPERIODM1ATRPeriod;

InitialiserlesindicateursM5pouralignementdetendance
emaFastM5Handle=iMASymbolPERIODM5EMAFastPeriod0MODEEMAPRICECLOSE;
emaSlowM5Handle=iMASymbolPERIODM5EMASlowPeriod0MODEEMAPRICECLOSE;
atrM5Handle=iATRSymbolPERIODM5ATRPeriod;

InitialiserlesindicateursH1pouralignementdetendance
emaFastH1Handle=iMASymbolPERIODH1EMAFastPeriod0MODEEMAPRICECLOSE;
emaSlowH1Handle=iMASymbolPERIODH1EMASlowPeriod0MODEEMAPRICECLOSE;
atrH1Handle=iATRSymbolPERIODH1ATRPeriod;

InitialiserlATRM1poursupportsrsistancesetordreslimits
atrM1Handle=iATRSymbolPERIODM1ATRPeriod;

InitialiserlesEMApourtendanceslongues50100200surM1
ema50Handle=iMASymbolPERIODM1500MODEEMAPRICECLOSE;
ema100Handle=iMASymbolPERIODM11000MODEEMAPRICECLOSE;
ema200Handle=iMASymbolPERIODM12000MODEEMAPRICECLOSE;

ifemaFastHandle==INVALIDHANDLEemaSlowHandle==INVALIDHANDLE
emaFastH1Handle==INVALIDHANDLEemaSlowH1Handle==INVALIDHANDLE
emaFastM5Handle==INVALIDHANDLEemaSlowM5Handle==INVALIDHANDLE
ema50Handle==INVALIDHANDLEema100Handle==INVALIDHANDLEema200Handle==INVALIDHANDLE
rsiHandle==INVALIDHANDLEatrHandle==INVALIDHANDLE
atrM5Handle==INVALIDHANDLEatrH1Handle==INVALIDHANDLEatrM1Handle==INVALIDHANDLE

PrintErreurinitialisationindicateurs;
returnINITFAILED;


VrifierlURLIA
ifUseAIAgentStringLenAIServerURL>0

AjouterlURLlalisteautorise
stringurlDomain=AIServerURL;
intprotocolPos=StringFindurlDomain:;
ifprotocolPos>=0

urlDomain=StringSubstrurlDomainprotocolPos3;
intpathPos=StringFindurlDomain;
ifpathPos>0
urlDomain=StringSubstrurlDomain0pathPos;


PrintRobotScalperDoubleinitialis;
PrintURLServeurIA:AIServerURL;
PrintLotinitial:InitialLotSize;
PrintTP:TakeProfitUSDUSD;
PrintSL:StopLossUSDUSD;


Initialiserlesuiviquotidien
glastDayReset=TimeCurrent;
ResetDailyCounters;

Nettoyertouslesobjetsgraphiquesaudmarrage
CleanAllGraphicalObjects;

returnINITSUCCEEDED;



Expertdeinitializationfunction

voidOnDeinitconstintreason

Librerleshandlesdesindicateurs
ifemaFastHandle=INVALIDHANDLEIndicatorReleaseemaFastHandle;
ifemaSlowHandle=INVALIDHANDLEIndicatorReleaseemaSlowHandle;
ifemaFastH1Handle=INVALIDHANDLEIndicatorReleaseemaFastH1Handle;
ifemaSlowH1Handle=INVALIDHANDLEIndicatorReleaseemaSlowH1Handle;
ifemaFastM5Handle=INVALIDHANDLEIndicatorReleaseemaFastM5Handle;
ifemaSlowM5Handle=INVALIDHANDLEIndicatorReleaseemaSlowM5Handle;
ifema50Handle=INVALIDHANDLEIndicatorReleaseema50Handle;
ifema100Handle=INVALIDHANDLEIndicatorReleaseema100Handle;
ifema200Handle=INVALIDHANDLEIndicatorReleaseema200Handle;
ifrsiHandle=INVALIDHANDLEIndicatorReleasersiHandle;
ifatrHandle=INVALIDHANDLEIndicatorReleaseatrHandle;
ifatrM5Handle=INVALIDHANDLEIndicatorReleaseatrM5Handle;
ifatrH1Handle=INVALIDHANDLEIndicatorReleaseatrH1Handle;

Nettoyerletableaudebord
CleanupDashboard;

PrintRobotScalperDoublearrt;



Experttickfunction

voidOnTick

Rinitialiserlescompteursquotidienssincessaire
ResetDailyCountersIfNeeded;

Initialiserletableaudebordaupremiertickseulementsiactiv
staticbooldashboardInitialized=false;
ifShowDashboardShowInfoOnChartdashboardInitialized

Initialiserlestatspardfaut
forinti=0;i<4;i

galignmentStatus[i=;
galignmentColors[i=clrGray;

UpdateAlignmentDashboard;
dashboardInitialized=true;

ifDebugMode
PrintInformationsIAactivessurlegraphique;


Vrifierleslimitesquotidiennesmodeprudentsiperteleve
Aulieudebloquercompltementonactiveunmodetrsprudent
boolcautiousMode=gdailyLoss>=MaxDailyLoss;
ifcautiousModeDebugMode
PrintMODEPRUDENTACTIV:PertequotidienneleveDoubleToStringgdailyLoss2USDSeulementopportunitstrssres;

ifgdailyProfit>=MaxDailyProfit

ifDebugMode
PrintProfitquotidienmaximalatteint:gdailyProfitUSD;
return;


Vrifierlapertetotalemaximaletoutespositionsactives
doubletotalLoss=GetTotalLoss;
iftotalLoss>=MaxTotalLoss

ifDebugMode
PrintPertetotalemaximaleatteinte:DoubleToStringtotalLoss2USDlimite:DoubleToStringMaxTotalLoss2USDBlocagedetouslesnouveauxtrades;
return;


MettrejourlIAsincessaire
staticdatetimelastAIUpdate=0;
ifUseAIAgentTimeCurrentlastAIUpdate>=AIUpdateInterval

UpdateAIDecision;
lastAIUpdate=TimeCurrent;


MettrejourlanalysedetendanceAPIsincessaire
staticdatetimelastTrendUpdate=0;
ifUseTrendAPIAnalysisTimeCurrentlastTrendUpdate>=AIUpdateInterval

UpdateTrendAPIAnalysis;
lastTrendUpdate=TimeCurrent;


MettrejourlesdonnesdesendpointsRenderRACTIVPOURPRDICTIONS
staticdatetimelastEndpointUpdate=0;
intendpointInterval=HighPerformanceMode?120:60;Toutesles2minutesenmodehauteperf
ifUseAllEndpointsTimeCurrentlastEndpointUpdate>=endpointInterval

glastAnalysisData=UpdateAnalysisEndpoint;
glastTrendData=UpdateTrendEndpoint;
glastPredictionData=UpdatePredictionEndpoint;
glastCoherentData=UpdateCoherentEndpoint;
glastEndpointUpdate=TimeCurrent;

ifDebugMode

PrintDonnesendpointsmisesjourprdictionactive:;
PrintAnalyse:glastAnalysisData=?:;
PrintTendance:glastTrendData=?:;
PrintPrdiction:glastPredictionData=?:;
PrintCohrent:glastCoherentData=?:;


Dessinerlesprdictionssurlegraphique
ifglastPredictionData=

DrawPredictionsOnChartglastPredictionData;


Dtecteretafficherlescorrectionsversrsistancessupports
DetectAndDisplayCorrections;

Forcerlamisejourdutableaudebord
ifShowDashboardShowInfoOnChartglastAIAction=

ENUMORDERTYPEdummyType=glastAIAction==buy?ORDERTYPEBUY:ORDERTYPESELL;
CheckAllEndpointsAlignmentdummyType;



OPTIMISATION:Diagnosticstrspeufrquentsdsactivsimodesilencieux
staticdatetimelastDiagnostic=0;
ifDebugModeDisableNotificationsTimeCurrentlastDiagnostic>=600Toutesles10minutes

Print\n===DIAGNOSTICROBOToptimis===;
PrintModehauteperformance:HighPerformanceMode?ACTIV:DSACTIV;
PrintGraphiquesdsactivs:DisableAllGraphics?ACTIV:DSACTIV;
PrintNotificationsdsactives:DisableNotifications?ACTIV:DSACTIV;
PrintPositionsactives:PositionsTotal;
PrintSymbolesactifs:CountActiveSymbols;
PrintPertequotidienne:DoubleToStringgdailyLoss2;
PrintDernireactionIA:glastAIActionconf:DoubleToStringglastAIConfidence1001;
PrintModefallbackIA:gaiFallbackMode?ACTIV:DSACTIV;
PrintEndpointsaligns:DoubleToStringgendpointsAlignment1001;
Print============================\n;
lastDiagnostic=TimeCurrent;


OPTIMISATIONMAXIMALE:Dsactivercompltementlesgraphiques
ifDisableAllGraphics

staticdatetimelastDrawUpdate=0;
intgraphicsInterval=HighPerformanceMode?GraphicsUpdateInterval:30;
ifTimeCurrentlastDrawUpdate>=graphicsInterval

Seulementleslabelsessentielstrslger
DrawAIConfidenceAndTrendSummary;

lastDrawUpdate=TimeCurrent;



OPTIMISATION:Misesjourtrspeufrquentespourlmentslourdsdsactivsigraphicsdsactivs
ifDisableAllGraphics

staticdatetimelastHeavyUpdate=0;
ifTimeCurrentlastHeavyUpdate>=600Toutesles10minutesaulieude5

Nettoyerseulementlesobjetsobsoltes
CleanOldGraphicalObjects;

AfficherEMAlonguesoptimistrspeufrquent
ifShowLongTrendEMA
DrawLongTrendEMA;

FORCER:AffichersupportrsistanceTOUJOURStrsimportant
DrawSupportResistanceLevels;

NOUVEAU:Dessinerlesbougiesfuturesadaptesautimeframe
DrawFutureCandlesAdaptive;

Affichertrendlinestrspeufrquent
ifDrawTrendlines
DrawTrendlinesOnChart;

lastHeavyUpdate=TimeCurrent;



SCURISATIONDESPROFITS:Optimisappelseulementdanslagestiondespositions
viterlappeldirecticipourrduirelachargeCPU

Derivpatternsdsactivsigraphicsdsactivs
ifDisableAllGraphicsDrawDerivPatterns

staticdatetimelastDerivUpdate=0;
intderivInterval=HighPerformanceMode?30:15;Toutesles30secondesenmodehauteperf
ifTimeCurrentlastDerivUpdate>=derivInterval

DrawDerivPatternsOnChart;
UpdateDerivArrowBlink;
lastDerivUpdate=TimeCurrent;



OPTIMISATION:VrifierlespositionsmoinsfrquemmentULTRA
staticdatetimelastPositionCheck=0;
intcheckInterval=HighPerformanceMode?PositionCheckInterval:2;
ifTimeCurrentlastPositionCheck>=checkInterval

CheckAndManagePositions;
SecureDynamicProfits;Appeliciseulement

Activersystmatiquementletrailingstopsurtouteslespositionsouvertes
CelagarantitquedsquunepositionprogressesonSLestajustautomatiquement
ActivateTrailingStop;

lastPositionCheck=TimeCurrent;


Sipasdepositionchercheruneopportunitbeaucoupmoinsfrquent
staticdatetimelastOpportunityCheck=0;
intopportunityInterval=HighPerformanceMode?15:3;
ifghasPositionTimeCurrentlastOpportunityCheck>=opportunityInterval

LookForTradingOpportunity;
lastOpportunityCheck=TimeCurrent;




Rinitialiserlescompteursquotidiens

voidResetDailyCountersIfNeeded

MqlDateTimedt;
TimeToStructTimeCurrentdt;
MqlDateTimelastDt;
TimeToStructglastDayResetlastDt;

ifdtday=lastDtdaydtmon=lastDtmondtyear=lastDtyear

ResetDailyCounters;
glastDayReset=TimeCurrent;



voidResetDailyCounters

gdailyProfit=00;
gdailyLoss=00;

Calculerleprofitperteactueldepuislhistorique
datetimestartOfDay=StringToTimeTimeToStringTimeCurrentTIMEDATE;
datetimeendOfDay=startOfDay86400;

ifHistorySelectstartOfDayendOfDay

inttotalDeals=HistoryDealsTotal;
forinti=0;i<totalDeals;i

ulongticket=HistoryDealGetTicketi;
ifticket==0continue;

Vrifiersicestuntradedeclture
ifHistoryDealGetIntegerticketDEALENTRY=DEALENTRYOUT
continue;

VrifiersicestnotreEA
ifHistoryDealGetIntegerticketDEALMAGIC=InpMagicNumber
continue;

Rcuprerleprofit
doubleprofit=HistoryDealGetDoubleticketDEALPROFIT;
ifprofit>0
gdailyProfit=profit;
else
gdailyLoss=MathAbsprofit;





MettrejourladcisionIA

voidUpdateAIDecision

ifUseAIAgentStringLenAIServerURL==0
return;

Rcuprerlesdonnesdemarch
doublebid=SymbolInfoDoubleSymbolSYMBOLBID;
doubleask=SymbolInfoDoubleSymbolSYMBOLASK;
doublemidPrice=bidask20;

Rcuprerlesindicateurs
doubleemaFast[emaSlow[emaFastH1[emaSlowH1[rsi[atr[;
ArraySetAsSeriesemaFasttrue;
ArraySetAsSeriesemaSlowtrue;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;
ArraySetAsSeriesrsitrue;
ArraySetAsSeriesatrtrue;

ifCopyBufferemaFastHandle001emaFast<=0
CopyBufferemaSlowHandle001emaSlow<=0
CopyBufferemaFastH1Handle001emaFastH1<=0
CopyBufferemaSlowH1Handle001emaSlowH1<=0
CopyBufferrsiHandle001rsi<=0
CopyBufferatrHandle001atr<=0

ifDebugMode
PrintErreurrcuprationindicateurspourIA;
return;


CalculerladirectionbasesurEMA
intdirRule=0;
ifemaFast[0>emaSlow[0
dirRule=1;Uptrend
elseifemaFast[0<emaSlow[0
dirRule=1;Downtrend

ConstruireleJSONpourlIA
stringsafeSymbol=Symbol;
StringReplacesafeSymbol\\\\;

stringpayload=;
payload=\symbol\:\safeSymbol\;
payload=\bid\:DoubleToStringbidDigits;
payload=\ask\:DoubleToStringaskDigits;
payload=\rsi\:DoubleToStringrsi[02;
payload=\emafasth1\:DoubleToStringemaFastH1[0Digits;
payload=\emaslowh1\:DoubleToStringemaSlowH1[0Digits;
payload=\emafastm1\:DoubleToStringemaFast[0Digits;
payload=\emaslowm1\:DoubleToStringemaSlow[0Digits;
payload=\atr\:DoubleToStringatr[0Digits;
payload=\dirrule\:IntegerToStringdirRule;
payload=\isspikemode\:false;
payload=;

ConversionenUTF8
intpayloadLen=StringLenpayload;
chardata[;
ArrayResizedatapayloadLen1;
intcopied=StringToCharArraypayloaddata0WHOLEARRAYCPUTF8;

ifcopied<=0

ifDebugMode
PrintErreurconversionJSON;
return;


ArrayResizedatacopied1;

Envoyerlarequteavecgestionlocaldistant
charresult[;
stringheaders=ContentType:applicationjson\r\nUserAgent:MT5TradBOT30\r\n;
stringresultheaders=;

Variablespoursuivrelasourceutilise
stringusedURL=;
boolrequestSuccess=false;
intres=1;

Essayerdabordleserveurlocalsidisponible
ifStringFindAIServerURLlocalhost>=0StringFindAIServerURL127001>=0

usedURL=AIServerURL;
ifDebugMode
PrintTentativedeconnexionauserveurlocal:usedURL;

Rduireletimeoutpourleserveurlocal
res=WebRequestPOSTusedURLheaders3000dataresultresultheaders;

ifres==200

requestSuccess=true;
glastAISource=0;0=Local



SichecduserveurlocalounonutilisessayerleserveurdistantRender
ifrequestSuccess

UtiliserlURLRenderpardfaut
usedURL=https:kolatradebotonrendercomdecision;
ifDebugMode
PrintTentativedeconnexionauserveurdistant:usedURL;

res=WebRequestPOSTusedURLheadersAITimeoutmsdataresultresultheaders;

ifres==200

requestSuccess=true;
glastAISource=1;1=Render



ifrequestSuccess

interrorCode=GetLastError;
gaiConsecutiveFailures;

ifDebugMode
PrintAIWebRequestchec:http=resErreurMT5:errorCodeURL:usedURL;

GestionamlioredeserreursHTTP
ifres==404

PrintERREUR404:EndpointnontrouvVrifiezlURLduserveur;
PrintURLactuelle:usedURL;
PrintSolution:VrifiezqueleserveurestaccessibleetlURLcorrecte;

elseifres==403

PrintERREUR403:AccsrefusVrifiezlaclAPI;
PrintSolution:VrifiezvotreclAPIouabonnement;

elseifres==500

PrintERREUR500:Erreurserveurinterne;
PrintSolution:Ressayezplustardoucontactezlesupport;

elseifres==429

PrintERREUR429:TropderequtesLimitedpasse;
PrintSolution:Rduisezlafrquencedesrequtes;


ifgaiConsecutiveFailures>=AIFAILURETHRESHOLDgaiFallbackMode

gaiFallbackMode=true;
PrintMODEDGRADACTIV:ServeurIAindisponible;


iferrorCode==4060

PrintERREUR4060:URLnonautorisedansMT5;
PrintAllezdans:Outils>Options>ExpertAdvisors;
PrintAjoutez:http:127001ouhttps:votreserveurlocalcom;

return;


Succs
gaiConsecutiveFailures=0;
ifgaiFallbackMode

gaiFallbackMode=false;
ifDebugMode
PrintMODEDGRADDSACTIV:ServeurIAdisponible;


stringresp=CharArrayToStringresult01CPUTF8;

ifDebugMode
PrintRponseIAreue:StringSubstrresp0300;Afficherles300premierscaractres

Rinitialiserlesvaleursavantparsing
glastAIAction=;
glastAIConfidence=00;
glastAIReason=;

ParserlarponseJSONdemanireplusrobuste
1Parseractionrechercheavecgestiondesespaces
intactionPos=StringFindresp\action\;
ifactionPos<0
actionPos=StringFindrespaction;Essayersansguillemets

ifactionPos>=0

Chercherledeuxpointsaprsaction
intcolonPos=StringFindresp:actionPos;
ifcolonPos>actionPos

Chercherlavaleurentreguillemetspeutavoirdesespacesavant
intsearchStart=colonPos1;
intquoteStart=1;

Chercherlepremierguillemetaprsledeuxpoints
forinti=searchStart;i<StringLenrespi<searchStart20;i

ifStringGetCharacterrespi==

quoteStart=i;
break;



ifquoteStart>0

intquoteEnd=StringFindresp\quoteStart1;
ifquoteEnd>quoteStart

stringactionValue=StringSubstrrespquoteStart1quoteEndquoteStart1;
StringTrimLeftactionValue;
StringTrimRightactionValue;
StringToLoweractionValue;

Grerdiffrentsformatspossibles
ifStringFindactionValuebuy==0StringFindactionValueachat==0
glastAIAction=buy;
elseifStringFindactionValuesell==0StringFindactionValuevente==0
glastAIAction=sell;
else
glastAIAction=hold;





Fallbackpouractionsiparsingchoue
ifglastAIAction==

stringrespLower=resp;
StringToLowerrespLower;
Rechercheplusprcisepourviterlesfauxpositifs
intbuyPos=StringFindrespLower\buy\;
intsellPos=StringFindrespLower\sell\;
intholdPos=StringFindrespLower\hold\;

ifbuyPos>=0sellPos<0buyPos<sellPosholdPos<0buyPos<holdPos
glastAIAction=buy;
elseifsellPos>=0holdPos<0sellPos<holdPos
glastAIAction=sell;
else
glastAIAction=hold;


2Parserconfidencegestionamlioredesnombresdcimaux
intconfPos=StringFindresp\confidence\;
ifconfPos<0
confPos=StringFindrespconfidence;

ifconfPos>=0

intcolon=StringFindresp:confPos;
ifcolon>confPos

Chercherlafindunombrevirguleaccoladeouespace
intendPos=StringFindrespcolon;
ifendPos<0

endPos=StringFindrespcolon;
ifendPos<0
endPos=StringFindresp\ncolon;
ifendPos<0
endPos=StringFindresp\rcolon;


ifendPos>colon

stringconfStr=StringSubstrrespcolon1endPoscolon1;
StringTrimLeftconfStr;
StringTrimRightconfStr;

Nettoyerlachaneenleverespacesretourslaligne
stringcleanConf=;
forinti=0;i<StringLenconfStr;i

ushortch=StringGetCharacterconfStri;
ifch>=0ch<=9ch==ch==ch==
cleanConf=ShortToStringch;


ifStringLencleanConf>0

doubleconfValue=StringToDoublecleanConf;
Validerquelaconfianceestdansuneplageraisonnable
ifconfValue>=00confValue<=10
glastAIConfidence=confValue1000;Convertirdedcimalpourcentage
elseifconfValue>10confValue<=1000
glastAIConfidence=confValue;Djenpourcentage
else

ifDebugMode
PrintConfianceIAinvalide:confValuechanebrute:confStr;


elseifDebugMode
PrintImpossibledextrairelaconfiancedepuis:confStr;




3Parserreasongestionamlioredeschanesaveccaractresspciaux
intreasonPos=StringFindresp\reason\;
ifreasonPos<0
reasonPos=StringFindrespreason;

ifreasonPos>=0

intcolonR=StringFindresp:reasonPos;
ifcolonR>reasonPos

Chercherlepremierguillemetaprsledeuxpoints
intsearchStart=colonR1;
intstartQuote=1;

forinti=searchStart;i<StringLenrespi<searchStart50;i

ifStringGetCharacterrespi==

startQuote=i;
break;



ifstartQuote>0

Chercherleguillemetdefinpeuttrechapp
intendQuote=1;
forinti=startQuote1;i<StringLenrespi<startQuote500;i

ushortch=StringGetCharacterrespi;
ifch==

Vrifiersicestchapp
ifi>0StringGetCharacterrespi1=\\

endQuote=i;
break;




ifendQuote>startQuote

glastAIReason=StringSubstrrespstartQuote1endQuotestartQuote1;
DcoderleschappementsJSONbasiques
StringReplaceglastAIReason\\\\;
StringReplaceglastAIReason\\n\n;
StringReplaceglastAIReason\\r\r;
StringReplaceglastAIReason\\t\t;





Validationfinale
ifglastAIAction==

glastAIAction=hold;
ifDebugMode
PrintActionIAnontrouveutilisationdeholdpardfaut;


ifglastAIConfidence<00glastAIConfidence>1000

ifDebugMode
PrintConfianceIAinvalideglastAIConfidencerinitialisation00;
glastAIConfidence=00;


ExtraireleszonesBUYSELLdepuislarponseJSON
ExtractAIZonesFromResponseresp;

glastAITime=TimeCurrent;

ifDebugMode
PrintIA:glastAIActionconfiance:DoubleToStringglastAIConfidence2glastAIReason;



MettrejourlanalysedetendanceAPI

voidUpdateTrendAPIAnalysis

ifUseTrendAPIAnalysisStringLenTrendAPIURL==0
return;

ConstruirelURLaveclesparamtressymbolettimeframe
stringsafeSymbol=Symbol;
StringReplacesafeSymbol20;
stringurl=TrendAPIURL?symbol=safeSymboltimeframe=M1;

PrparerlarequteGET
chardata[;
ArrayResizedata0;
charresult[;
stringheaders=Accept:applicationjson\r\n;
stringresultheaders=;

intres=WebRequestGETurlheadersAITimeoutmsdataresultresultheaders;

ifres<200res>=300

ifDebugMode
PrintErreurrcuprationAPITrend:http=res;
gapitrendvalid=false;
return;


Parserlarponse
stringresp=CharArrayToStringresult01CPUTF8;
ParseTrendAPIResponseresp;



ParserlarponsedelAPIdetendance

voidParseTrendAPIResponsestringjsonresponse

gapitrendvalid=false;
gapitrenddirection=0;
gapitrendstrength=00;
gapitrendconfidence=00;
gapitrendsignal=;

Parserladirection
intdirPos=StringFindjsonresponse\direction\;
ifdirPos>=0

intcolon=StringFindjsonresponse:dirPos;
ifcolon>0

ChercherBUYSELLouNEUTRE
stringdirStr=StringSubstrjsonresponsecolon120;
StringToUpperdirStr;
ifStringFinddirStrBUY>=0StringFinddirStr1>=0
gapitrenddirection=1;
elseifStringFinddirStrSELL>=0StringFinddirStr1>=0
gapitrenddirection=1;
else
gapitrenddirection=0;



Parserlaforcestrength
intstrPos=StringFindjsonresponse\strength\;
ifstrPos>=0

intcolon=StringFindjsonresponse:strPos;
ifcolon>0

intendPos=StringFindjsonresponsecolon;
ifendPos<0endPos=StringFindjsonresponsecolon;
ifendPos>colon

stringstrStr=StringSubstrjsonresponsecolon1endPoscolon1;
gapitrendstrength=StringToDoublestrStr;




Parserlaconfianceconfidence
intconfPos=StringFindjsonresponse\confidence\;
ifconfPos>=0

intcolon=StringFindjsonresponse:confPos;
ifcolon>0

intendPos=StringFindjsonresponsecolon;
ifendPos<0endPos=StringFindjsonresponsecolon;
ifendPos>colon

stringconfStr=StringSubstrjsonresponsecolon1endPoscolon1;
gapitrendconfidence=StringToDoubleconfStr;




Parserlesignal
intsigPos=StringFindjsonresponse\signal\;
ifsigPos>=0

intcolon=StringFindjsonresponse:sigPos;
ifcolon>0

intstartQuote=StringFindjsonresponse\colon;
ifstartQuote>0

intendQuote=StringFindjsonresponse\startQuote1;
ifendQuote>startQuote
gapitrendsignal=StringSubstrjsonresponsestartQuote1endQuotestartQuote1;




Validerlesdonnessilaconfianceestsuffisante
ifgapitrendconfidence>=TrendAPIMinConfidence

gapitrendvalid=true;
gapitrendlastupdate=TimeCurrent;

ifDebugMode

stringdirStr=gapitrenddirection==1?BUY:gapitrenddirection==1?SELL:NEUTRE;
PrintAPITrend:dirStrForce:DoubleToStringgapitrendstrength1
Confiance:DoubleToStringgapitrendconfidence1;


else

ifDebugMode
PrintAPITrend:ConfianceinsuffisanteDoubleToStringgapitrendconfidence1
<DoubleToStringTrendAPIMinConfidence1;




ExtraireleszonesBUYSELLdepuislarponseJSONdelIA

voidExtractAIZonesFromResponsestringresp

Extrairebuyzonelow
intbuyLowPos=StringFindresp\buyzonelow\;
ifbuyLowPos>=0

intcolon=StringFindresp:buyLowPos;
ifcolon>0

intendPos=StringFindrespcolon;
ifendPos<0endPos=StringFindrespcolon;
ifendPos>colon

stringbuyLowStr=StringSubstrrespcolon1endPoscolon1;
StringTrimLeftbuyLowStr;
StringTrimRightbuyLowStr;
ifbuyLowStr=nullbuyLowStr=StringLenbuyLowStr>0
gaiBuyZoneLow=StringToDoublebuyLowStr;




Extrairebuyzonehigh
intbuyHighPos=StringFindresp\buyzonehigh\;
ifbuyHighPos>=0

intcolon=StringFindresp:buyHighPos;
ifcolon>0

intendPos=StringFindrespcolon;
ifendPos<0endPos=StringFindrespcolon;
ifendPos>colon

stringbuyHighStr=StringSubstrrespcolon1endPoscolon1;
StringTrimLeftbuyHighStr;
StringTrimRightbuyHighStr;
ifbuyHighStr=nullbuyHighStr=StringLenbuyHighStr>0
gaiBuyZoneHigh=StringToDoublebuyHighStr;




Extrairesellzonelow
intsellLowPos=StringFindresp\sellzonelow\;
ifsellLowPos>=0

intcolon=StringFindresp:sellLowPos;
ifcolon>0

intendPos=StringFindrespcolon;
ifendPos<0endPos=StringFindrespcolon;
ifendPos>colon

stringsellLowStr=StringSubstrrespcolon1endPoscolon1;
StringTrimLeftsellLowStr;
StringTrimRightsellLowStr;
ifsellLowStr=nullsellLowStr=StringLensellLowStr>0
gaiSellZoneLow=StringToDoublesellLowStr;




Extrairesellzonehigh
intsellHighPos=StringFindresp\sellzonehigh\;
ifsellHighPos>=0

intcolon=StringFindresp:sellHighPos;
ifcolon>0

intendPos=StringFindrespcolon;
ifendPos<0endPos=StringFindrespcolon;
ifendPos>colon

stringsellHighStr=StringSubstrrespcolon1endPoscolon1;
StringTrimLeftsellHighStr;
StringTrimRightsellHighStr;
ifsellHighStr=nullsellHighStr=StringLensellHighStr>0
gaiSellZoneHigh=StringToDoublesellHighStr;




ifDebugModegaiBuyZoneLow>0gaiSellZoneLow>0
PrintZonesIAextraitesBUY:gaiBuyZoneLowgaiBuyZoneHighSELL:gaiSellZoneLowgaiSellZoneHigh;



Vrifieretgrerlespositionsexistantes

voidCheckAndManagePositions

ghasPosition=false;

FermetureglobaleVolatilitysipertecumuledpasse7
CloseVolatilityIfLossExceeded70;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

ghasPosition=true;

Mettrejourletracker
ifgpositionTrackerticket=ticket

gpositionTrackerticket=ticket;
gpositionTrackerinitialLot=positionInfoVolume;
gpositionTrackercurrentLot=positionInfoVolume;
gpositionTrackerhighestProfit=00;
gpositionTrackerlotDoubled=false;
gpositionTrackeropenTime=datetimepositionInfoTime;
gpositionTrackermaxProfitReached=00;
gpositionTrackerprofitSecured=false;


Vrifierleprofitactueletmettrejourleprofitmaximum
doublecurrentProfit=positionInfoProfit;
ifcurrentProfit>gpositionTrackerhighestProfit
gpositionTrackerhighestProfit=currentProfit;

Mettrejourleprofitmaximumatteintpourcetteposition
ifcurrentProfit>gpositionTrackermaxProfitReached
gpositionTrackermaxProfitReached=currentProfit;

NOUVEAU:ScurisationCONTINUEdsquilyaunprofit
Appelchaqueticksilapositionestenprofitpasseulementquandleprofitaugmente
CelagarantitqueleSLesttoujoursajustpourscuriseraumoins50desgains
ifcurrentProfit>010Minimum010pourvitertropdemodifications

SecureProfitForPositionticketcurrentProfit;


NOUVELLELOGIQUE:FermersiperteindividuelleatteintMaxLossPerPositionPROTECTIONMAXIMALE
ifcurrentProfit<=MaxLossPerPosition

iftradePositionCloseticket

PrintPositionferme:PertemaximaleatteinteDoubleToStringcurrentProfit2<=DoubleToStringMaxLossPerPosition2PROTECTION;
continue;



NOUVELLELOGIQUE:Fermersiprofitindividuelatteint2
ifcurrentProfit>=20

iftradePositionCloseticket

PrintPositionferme:ProfitindividuelatteintDoubleToStringcurrentProfit2>=200;
continue;



LOGIQUE:FermersiIAchangeenholdouchangededirection
AppliquTOUSlessymbolespasseulementBoomCrash
ifUseAIAgentglastAIAction=

ENUMPOSITIONTYPEposType=positionInfoPositionType;
boolshouldClose=false;
stringcloseReason=;

SiIArecommandeholdfermerposition
ifglastAIAction==hold

shouldClose=true;
closeReason=IArecommandemaintenantATTENTE;
ifDebugMode
PrintPositionferme:closeReasonRecherchemeilleureentreprochainement;

SiIAchangededirectionBUY>SELLouSELL>BUY
elseifposType==POSITIONTYPEBUYglastAIAction==sell
posType==POSITIONTYPESELLglastAIAction==buy

shouldClose=true;
closeReason=IAchangededirection;
ifDebugMode

stringactionUpper=glastAIAction;
StringToUpperactionUpper;
PrintPositionferme:closeReasonpositionposType==POSITIONTYPEBUY?BUY:SELL
>IArecommandeactionUpperRecherchemeilleureentreprochainement;



ifshouldClose

iftradePositionCloseticket

PrintPositionfermesuitechangementIA:closeReasonProfit=DoubleToStringcurrentProfit2;
continue;




Vrifiersiondoitdoublerlelot
datetimenow=TimeCurrent;
intpositionAge=intnowgpositionTrackeropenTime;

ifgpositionTrackerlotDoubled
currentProfit>=ProfitThresholdForDouble
positionAge>=MinPositionLifetimeSec

DoublePositionLotticket;


VrifierlesSLTPgrsparlebrokermaisonpeutvrifier
doublesl=positionInfoStopLoss;
doubletp=positionInfoTakeProfit;

SipasdeSLTPlesdfiniraveclimitedepertemax3
ifsl==0tp==0

SetFixedSLTPWithMaxLossticket30;Limitedepertemax3parposition


PourBoomCrash:Fermeraprsspikemmeavecpetitgain02minimum
boolisBoomCrash=StringFindSymbolBoom=1StringFindSymbolCrash=1;
boolisForex=IsForexSymbolSymbol;

ifisBoomCrash

CloseBoomCrashAfterSpiketicketcurrentProfit;


PROTECTIONFOREX:NepasfermerlespositionsForextropviteminimum60secondes
LespositionsForexdoiventavoirletempsdesedvelopperavantfermeture
ifisForexisBoomCrash

datetimeopenTime=datetimepositionInfoTime;
intpositionAge=intTimeCurrentopenTime;

Sipositiontroprcente<60setenpetiteperteattendre
ifpositionAge<60currentProfit<0currentProfit>10

ifDebugMode
PrintPositionForextroprcentepositionAges<60setpetiteperteDoubleToStringcurrentProfit2Attendredveloppement;
Nepasfermercontinuerlaboucle
break;



NOUVELLELOGIQUE:FermerlespositionssileprixsortdelazoneIAetentreencorrection
UNIQUEMENTpourBoomCrashpaspourleforexquidoitattendreSLTP
vitedegarderdespositionspendantlescorrectionssurBoomCrash
ifisBoomCrash

ENUMPOSITIONTYPEposType=positionInfoPositionType;
ifposType==POSITIONTYPEBUY

CheckAndCloseBuyOnCorrectionticketcurrentProfit;

elseifposType==POSITIONTYPESELL

CheckAndCloseSellOnCorrectionticketcurrentProfit;



break;Uneseulepositionlafois




Siplusdepositionrinitialiserletracker
ifghasPosition

gpositionTrackerticket=0;
gpositionTrackerinitialLot=0;
gpositionTrackercurrentLot=0;
gpositionTrackerhighestProfit=00;
gpositionTrackerlotDoubled=false;
gpositionTrackermaxProfitReached=00;
gpositionTrackerprofitSecured=false;
gglobalMaxProfit=00;Rinitialiserleprofitglobalmax




NettoyerTOUSlesobjetsgraphiquesaudmarrage

voidCleanAllGraphicalObjects

SupprimerTOUSlesobjetsgraphiquessaufleslabelsessentiels
inttotal=ObjectsTotal0;
stringobjectsToKeep[=AICONFIDENCEAITRENDSUMMARY;

forinti=total1;i>=0;i

stringname=ObjectName0i;
ifname==
continue;

Vrifiersicestunobjetgarder
boolkeepObject=false;
forintk=0;k<ArraySizeobjectsToKeep;k

ifStringFindnameobjectsToKeep[k==0

keepObject=true;
break;



ifkeepObject
ObjectDelete0name;


ifDebugMode
PrintNettoyagecompletdesobjetsgraphiqueseffectu;



Nettoyerlesanciensobjetsgraphiques

voidCleanOldGraphicalObjects

OPTIMISATION:Nettoyageminimalseulementlesobjetsvraimentobsoltes
Nepasnettoyertropsouventpourviterderalentir
staticdatetimelastCleanup=0;
ifTimeCurrentlastCleanup<300Nettoyagemaxtoutesles5minutes
return;

Dclarerlestableauxaudbutdelafonction
stringprefixesToDelete[=DERIVDeriv;SupprimerseulementlespatternsDerivobsoltes
stringobjectsToKeep[=AICONFIDENCEAITRENDSUMMARYEMA50EMA100EMA200
AIBUYAISELLSRTrendSMCOBDERIVARROW;

Supprimerlesanciensobjetsgraphiquessaufceuxquonveutgarder
inttotal=ObjectsTotal0;
iftotal>1000Seulementnettoyersitropdobjets

Limiterlenettoyageaux100derniersobjetspourperformance
intstartIdx=MathMax0total100;
forinti=total1;i>=startIdx;i

stringname=ObjectName0i;
ifname==
continue;

Vrifiersicestunobjetgarder
boolkeepObject=false;
forintk=0;k<ArraySizeobjectsToKeep;k

ifStringFindnameobjectsToKeep[k==0

keepObject=true;
break;



ifkeepObject
continue;Gardercetobjet

Supprimerlesobjetsaveclesprfixessupprimer
forintj=0;j<ArraySizeprefixesToDelete;j

ifStringFindnameprefixesToDelete[j==0

ObjectDelete0name;
break;





lastCleanup=TimeCurrent;



DessinerconfianceIAetrsumsdetendancepartimeframe

voidDrawAIConfidenceAndTrendSummary

AfficherlarecommandationIAsidisponible
ifglastAIAction=glastAIConfidence>0

stringaiLabelName=AICONFIDENCESymbol;
ifObjectFind0aiLabelName<0
ObjectCreate0aiLabelNameOBJLABEL000;

ObjectSetInteger0aiLabelNameOBJPROPCORNERCORNERLEFTUPPER;
ObjectSetInteger0aiLabelNameOBJPROPXDISTANCE10;
ObjectSetInteger0aiLabelNameOBJPROPYDISTANCE30;

stringactionText=;
ifStringCompareglastAIActionbuy==0
actionText=BUY;
elseifStringCompareglastAIActionsell==0
actionText=SELL;
else
actionText=HOLD;

stringaiText=IA:actionTextDoubleToStringglastAIConfidence1;
ifglastAIReason=
aiText=\nStringSubstrglastAIReason050;

ObjectSetString0aiLabelNameOBJPROPTEXTaiText;
ObjectSetInteger0aiLabelNameOBJPROPCOLORclrWhite;
ObjectSetString0aiLabelNameOBJPROPFONTArial;
ObjectSetInteger0aiLabelNameOBJPROPFONTSIZE10;
ObjectSetInteger0aiLabelNameOBJPROPBACKfalse;

else

SupprimerlancienlabelsipasdesignalIA
stringaiLabelName=AICONFIDENCESymbol;
ifObjectFind0aiLabelName>=0
ObjectDelete0aiLabelName;


Rsumsdetendancepartimeframesidisponiblesdepuisapitrend
RcuprerlesEMApourafficherlestendances
doubleemaFastM1[emaSlowM1[emaFastM5[emaSlowM5[emaFastH1[emaSlowH1[;
ArraySetAsSeriesemaFastM1true;
ArraySetAsSeriesemaSlowM1true;
ArraySetAsSeriesemaFastM5true;
ArraySetAsSeriesemaSlowM5true;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;

boolhasData=true;
ifCopyBufferemaFastHandle001emaFastM1<=0
CopyBufferemaSlowHandle001emaSlowM1<=0
CopyBufferemaFastM5Handle001emaFastM5<=0
CopyBufferemaSlowM5Handle001emaSlowM5<=0
CopyBufferemaFastH1Handle001emaFastH1<=0
CopyBufferemaSlowH1Handle001emaSlowH1<=0
hasData=false;

ifhasData

intyOffset=50;
stringtrendText=Tendances:;

M1
stringm1Trend=emaFastM1[0>emaSlowM1[0?M1:M1;
trendText=m1Trend;

M5
stringm5Trend=emaFastM5[0>emaSlowM5[0?M5:M5;
trendText=m5Trend;

H1
stringh1Trend=emaFastH1[0>emaSlowH1[0?H1:H1;
trendText=h1Trend;

stringtrendLabelName=AITRENDSUMMARYSymbol;
ifObjectFind0trendLabelName<0
ObjectCreate0trendLabelNameOBJLABEL000;

ObjectSetInteger0trendLabelNameOBJPROPCORNERCORNERLEFTUPPER;
ObjectSetInteger0trendLabelNameOBJPROPXDISTANCE10;
ObjectSetInteger0trendLabelNameOBJPROPYDISTANCEyOffset;
ObjectSetString0trendLabelNameOBJPROPTEXTtrendText;
ObjectSetInteger0trendLabelNameOBJPROPCOLORclrWhite;
ObjectSetInteger0trendLabelNameOBJPROPFONTSIZE10;
ObjectSetString0trendLabelNameOBJPROPFONTArial;




AfficherltatdesendpointsRenderdansledashboard

voidDrawRenderEndpointsStatus

ifUseAllEndpointsreturn;

Labelpourltatdesendpoints
stringendpointsLabelName=ENDPOINTSSTATUSSymbol;
ifObjectFind0endpointsLabelName<0
ObjectCreate0endpointsLabelNameOBJLABEL000;

ObjectSetInteger0endpointsLabelNameOBJPROPCORNERCORNERLEFTUPPER;
ObjectSetInteger0endpointsLabelNameOBJPROPXDISTANCE10;
ObjectSetInteger0endpointsLabelNameOBJPROPYDISTANCE120;

stringendpointsText=Endpoints:;

Vrifierchaqueendpoint
boolanalysisOK=glastAnalysisData=;
booltrendOK=glastTrendData=;
boolpredictionOK=glastPredictionData=;
boolcoherentOK=glastCoherentData=;

endpointsText=analysisOK?:;
endpointsText=;
endpointsText=trendOK?:;
endpointsText=;
endpointsText=predictionOK?:;
endpointsText=;
endpointsText=coherentOK?:;

Ajouterlescoredalignement
ifgendpointsAlignment>0
endpointsText=DoubleToStringgendpointsAlignment1000;

ObjectSetString0endpointsLabelNameOBJPROPTEXTendpointsText;
ObjectSetInteger0endpointsLabelNameOBJPROPCOLORclrWhite;
ObjectSetInteger0endpointsLabelNameOBJPROPFONTSIZE10;
ObjectSetString0endpointsLabelNameOBJPROPFONTArial;



AffichelesinformationsIAdirectementsurlegraphique

voidUpdateAlignmentDashboard

ifShowDashboardShowInfoOnChartreturn;

Nettoyerlesanciensobjets
CleanupDashboard;

Obtenirleprixactuelpourpositionnerletexte
doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
datetimecurrentTime=TimeCurrent;

Positionnerletexteenhautgauchedugraphique
intx=20;
inty=30;

Ligne1:AlignementdesendpointsIAdecisionsupprimancienetsymbole
stringalignText=Alignement:DoubleToStringgendpointsAlignment1000;
stringalignName=gdashboardNameAlignement;
ObjectCreate0alignNameOBJTEXT0currentTimecurrentPriceSymbolInfoDoubleSymbolSYMBOLPOINT50;
ObjectSetString0alignNameOBJPROPTEXTalignText;
ObjectSetInteger0alignNameOBJPROPCOLORclrYellow;
ObjectSetInteger0alignNameOBJPROPFONTSIZE9;
ObjectSetString0alignNameOBJPROPFONTArial;
ObjectSetInteger0alignNameOBJPROPANCHORANCHORLEFT;
ObjectSetInteger0alignNameOBJPROPBACK0;

Lignes36:Statusdesendpointscompact
forinti=0;i<4;i

stringendpointText=gendpointNames[i:galignmentStatus[i;
stringendpointName=gdashboardNameEndpointIntegerToStringi;
ObjectCreate0endpointNameOBJTEXT0currentTimecurrentPriceSymbolInfoDoubleSymbolSYMBOLPOINT100i20;
ObjectSetString0endpointNameOBJPROPTEXTendpointText;
ObjectSetInteger0endpointNameOBJPROPCOLORgalignmentColors[i;
ObjectSetInteger0endpointNameOBJPROPFONTSIZE8;
ObjectSetString0endpointNameOBJPROPFONTArial;
ObjectSetInteger0endpointNameOBJPROPANCHORANCHORLEFT;
ObjectSetInteger0endpointNameOBJPROPBACK0;




Nettoielesobjetsdutableaudebord

voidCleanupDashboard

NettoyerlesanciensobjetsdetypeLABEL
forinti=0;i<4;i

stringlineName=gdashboardNameLineIntegerToStringi;
ObjectDelete0lineName;


Nettoyerlesanciensobjetsdutableaudebord
ObjectDelete0gdashboardNamePanel;
ObjectDelete0gdashboardNameTitle;
ObjectDelete0gdashboardNameScore;
ObjectDelete0gdashboardNameSignal;

NettoyerlesnouveauxobjetsTEXTsurlegraphique
ObjectDelete0gdashboardNameSignal;
ObjectDelete0gdashboardNameAlignement;

forinti=0;i<4;i

stringendpointName=gdashboardNameEndpointIntegerToStringi;
ObjectDelete0endpointName;




VrifieretfermerunepositionBUYsicorrectiondtecte
Fermesileprixsortdelazonedachatetentreencorrection

voidCheckAndCloseBuyOnCorrectionulongticketdoublecurrentProfit

ifpositionInfoSelectByTicketticket
return;

Nefermerquesionaunezonedachatdfinie
ifgaiBuyZoneLow<=0gaiBuyZoneHigh<=0
return;

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;

Vrifiersileprixestsortidelazonedachataudessus
ifcurrentPrice>gaiBuyZoneHigh

RcuprerlesEMAM1pourdtecterlacorrection
doubleemaFastM1[emaSlowM1[;
ArraySetAsSeriesemaFastM1true;
ArraySetAsSeriesemaSlowM1true;

ifCopyBufferemaFastHandle003emaFastM1<=0
CopyBufferemaSlowHandle003emaSlowM1<=0
return;

Dtectercorrection:EMArapidedescendsousEMAlenteOUprix<EMArapide
boolisCorrection=false;
ifemaFastM1[0<emaSlowM1[0currentPrice<emaFastM1[0

Vrifiersicestunecorrectionrcenteles2derniresbougies
ifemaFastM1[1>emaFastM1[0emaFastM1[2>emaFastM1[1

isCorrection=true;



Sicorrectiondtecteetprixsortidezonefermerlaposition
Maisseulementsionaunpetitprofitouunepetiteperteviterdeperdretrop
ifisCorrection

PROTECTION:Nepasfermertropviteminimum30secondesaprsouverture
datetimeopenTime=datetimepositionInfoTime;
intpositionAge=intTimeCurrentopenTime;
ifpositionAge<30

ifDebugMode
PrintPositionBUYtroprcentepositionAges<30sAttendreavantfermeturecorrection;
return;Nepasfermertropvite


Fermersiprofit>=0ouperte<=2limiterlespertes
ifcurrentProfit>=0currentProfit>=20

iftradePositionCloseticket

PrintPositionBUYferme:Prixsortidezonedachat[gaiBuyZoneLowgaiBuyZoneHighetcorrectiondtecteaprspositionAgesProfit=DoubleToStringcurrentProfit2;
RemoveSymbolFromExecutedListSymbol;

else

ifDebugMode
PrintErreurfermeturepositionBUY:tradeResultRetcodeDescription;


elseifDebugMode

PrintPositionBUYconservemalgrcorrection:PertetropimportanteDoubleToStringcurrentProfit2AttendreSLTP;






VrifieretfermerunepositionSELLsicorrectiondtecte
Fermesileprixsortdelazonedeventeetentreencorrection

voidCheckAndCloseSellOnCorrectionulongticketdoublecurrentProfit

ifpositionInfoSelectByTicketticket
return;

Nefermerquesionaunezonedeventedfinie
ifgaiSellZoneLow<=0gaiSellZoneHigh<=0
return;

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLASK;

Vrifiersileprixestsortidelazonedeventeendessous
ifcurrentPrice<gaiSellZoneLow

RcuprerlesEMAM1pourdtecterlacorrection
doubleemaFastM1[emaSlowM1[;
ArraySetAsSeriesemaFastM1true;
ArraySetAsSeriesemaSlowM1true;

ifCopyBufferemaFastHandle003emaFastM1<=0
CopyBufferemaSlowHandle003emaSlowM1<=0
return;

Dtectercorrection:EMArapidemonteaudessusdeEMAlenteOUprix>EMArapide
boolisCorrection=false;
ifemaFastM1[0>emaSlowM1[0currentPrice>emaFastM1[0

Vrifiersicestunecorrectionrcente
ifemaFastM1[1<emaFastM1[0emaFastM1[2<emaFastM1[1

isCorrection=true;



Sicorrectiondtecteetprixsortidezonefermerlaposition
ifisCorrection

PROTECTION:Nepasfermertropviteminimum30secondesaprsouverture
datetimeopenTime=datetimepositionInfoTime;
intpositionAge=intTimeCurrentopenTime;
ifpositionAge<30

ifDebugMode
PrintPositionSELLtroprcentepositionAges<30sAttendreavantfermeturecorrection;
return;Nepasfermertropvite


Fermersiprofit>=0ouperte<=2
ifcurrentProfit>=0currentProfit>=20

iftradePositionCloseticket

PrintPositionSELLferme:Prixsortidezonedevente[gaiSellZoneLowgaiSellZoneHighetcorrectiondtecteaprspositionAgesProfit=DoubleToStringcurrentProfit2;
RemoveSymbolFromExecutedListSymbol;

else

ifDebugMode
PrintErreurfermeturepositionSELL:tradeResultRetcodeDescription;


elseifDebugMode

PrintPositionSELLconservemalgrcorrection:PertetropimportanteDoubleToStringcurrentProfit2AttendreSLTP;






FermerlespositionsBoomCrashaprsspikeprofit>=seuil
Dtecteaussilespikeparmouvementdeprixrapide

voidCloseBoomCrashAfterSpikeulongticketdoublecurrentProfit

ifpositionInfoSelectByTicketticket
return;

Dtecterlespikeparmouvementdeprixrapide
staticdatetimeglastPriceCheck=0;

doublecurrentPrice=positionInfoPriceCurrent;
datetimenow=TimeCurrent;

Vrifiersicestunspikemouvementrapidedeprix
boolspikeDetected=false;
ifglastBoomCrashPrice>0nowglastPriceCheck<=5Vrifiertoutesles5secondesmax

doublepriceChange=MathAbscurrentPriceglastBoomCrashPrice;
doublepriceChangePercent=priceChangeglastBoomCrashPrice1000;

Sichangementdeprix>05enpeudetempscestunspike
ifpriceChangePercent>05

spikeDetected=true;
ifDebugMode
PrintSPIKEDTECT:SymbolChangementdeprix:DoubleToStringpriceChangePercent2;



glastBoomCrashPrice=currentPrice;
glastPriceCheck=now;

PourBoomCrash:fermerimmdiatementdsquonatteintleprofitminimalOUsispikedtect
ifcurrentProfit>=BoomCrashSpikeTPspikeDetected

iftradePositionCloseticket

stringreason=spikeDetected?Spikedtect:Profitseuilatteint;
PrintPositionBoomCrashferme:reasonProfit=DoubleToStringcurrentProfit2
seuil=DoubleToStringBoomCrashSpikeTP2;

Retirerlesymboledelalistepourpermettreunnouveautradeauprochainsignal
RemoveSymbolFromExecutedListSymbol;

Rinitialiserlesuividuprix
glastBoomCrashPrice=00;
glastPriceCheck=0;

else

PrintErreurfermeturepositionBoomCrash:tradeResultRetcode
tradeResultRetcodeDescription;





Doublerlelotdelaposition

voidDoublePositionLotulongticket

ifpositionInfoSelectByTicketticket
return;

doublecurrentLot=positionInfoVolume;
doublenewLot=currentLot20;

Vrifierlalimitemaximale
ifnewLot>MaxLotSize

ifDebugMode
PrintLotmaximumatteint:MaxLotSize;
return;


Vrifierlelotminimumetmaximumdubroker
doubleminLot=SymbolInfoDoubleSymbolSYMBOLVOLUMEMIN;
doublemaxLot=SymbolInfoDoubleSymbolSYMBOLVOLUMEMAX;
doublelotStep=SymbolInfoDoubleSymbolSYMBOLVOLUMESTEP;

Normaliserlelot
newLot=MathFloornewLotlotSteplotStep;
newLot=MathMaxminLotMathMinmaxLotnewLot;

Calculerlevolumeajouter
doublevolumeToAdd=newLotcurrentLot;

ifvolumeToAdd<=0
return;

Normaliserlevolumeajouter
volumeToAdd=NormalizeLotSizevolumeToAdd;

ifvolumeToAdd<SymbolInfoDoubleSymbolSYMBOLVOLUMEMIN

ifDebugMode
PrintVolumeajoutertroppetit:volumeToAdd;
return;


Ouvrirunenouvellepositiondanslemmesens
ENUMORDERTYPEorderType=positionInfoPositionType==POSITIONTYPEBUY?
ORDERTYPEBUY:ORDERTYPESELL;

doubleprice=orderType==ORDERTYPEBUY?
SymbolInfoDoubleSymbolSYMBOLASK:
SymbolInfoDoubleSymbolSYMBOLBID;

CalculerSLetTPdynamiquespourscuriserlesgains
Scuriseraumoins50desgainsdjraliss
doublecurrentProfit=positionInfoProfit;
ENUMPOSITIONTYPEposType=positionInfoPositionType;
doublesltp;

ifcurrentProfit<=0

PasencoredeprofitutiliserSLstandard
CalculateSLTPInPointsWithMaxLossposTypepricevolumeToAdd30sltp;
iftradePositionOpenSymbolorderTypevolumeToAddpricesltpDOUBLELOT

gpositionTrackercurrentLot=newLot;
gpositionTrackerlotDoubled=true;
PrintLotdoubl:currentLot>newLotajout:volumeToAdd;

else

PrintErreurdoublementlot:tradeResultRetcodetradeResultRetcodeDescription;

return;


doublemaxDrawdownAllowed=currentProfit05;50duprofitactuel=pertemaxaccepte
doublesecuredProfit=currentProfitmaxDrawdownAllowed;Profitscuris

doubleopenPrice=positionInfoPriceOpen;

CalculerSLdynamiquepourscuriserlesgains
CalculateDynamicSLTPForDoubleposTypeopenPricepricevolumeToAddsecuredProfitmaxDrawdownAllowedsltp;

MettrejourleSLdelapositionoriginaleaussipourscuriserlesgains
doublecurrentPriceForSL=positionInfoPriceCurrent;
doubleoriginalSLoriginalTP;
CalculateDynamicSLTPForDoubleposTypeopenPricecurrentPriceForSLcurrentLotsecuredProfitmaxDrawdownAllowedoriginalSLoriginalTP;

MettrejourleSLdelapositionoriginalepourscuriserlesgains
iforiginalSL>0

doublecurrentSL=positionInfoStopLoss;
boolshouldUpdateSL=false;

ifposType==POSITIONTYPEBUY

PourBUYlenouveauSLdoittremeilleurplushautquelactuel
ifcurrentSL==0originalSL>currentSL
shouldUpdateSL=true;

elseSELL

PourSELLlenouveauSLdoittremeilleurplusbasquelactuel
ifcurrentSL==0originalSL<currentSL
shouldUpdateSL=true;


ifshouldUpdateSL

tradePositionModifyticketoriginalSLpositionInfoTakeProfit;
ifDebugMode
PrintSLoriginalscuris:originalSLscuriseDoubleToStringsecuredProfit2;



iftradePositionOpenSymbolorderTypevolumeToAddpricesltpDOUBLELOT

gpositionTrackercurrentLot=newLot;
gpositionTrackerlotDoubled=true;

PrintLotdoubl:currentLot>newLotajout:volumeToAddavecSLTPdynamiquesscuriseDoubleToStringsecuredProfit2;

else

PrintErreurdoublementlot:tradeResultRetcodetradeResultRetcodeDescription;




DfinirSLTPfixesenUSDaveclimitedepertemaximale

voidSetFixedSLTPWithMaxLossulongticketdoublemaxLossUSD

ifpositionInfoSelectByTicketticket
return;

doubleopenPrice=positionInfoPriceOpen;
doublecurrentPrice=positionInfoPriceCurrent;
ENUMPOSITIONTYPEposType=positionInfoPositionType;
doublelotSize=positionInfoVolume;

CalculerSLetTPaveclimitedepertemax
doublesltp;
CalculateSLTPInPointsWithMaxLossposTypeopenPricelotSizemaxLossUSDsltp;

iftradePositionModifyticketsltp

ifDebugMode
PrintSLTPdfinisaveclimitepertemaxDoubleToStringmaxLossUSD2:SL=slTP=tp;

else

ifDebugMode
PrintErreurmodificationSLTP:tradeResultRetcode;




DfinirSLTPfixesenUSD

voidSetFixedSLTPulongticket

SetFixedSLTPWithMaxLossticket30;Utiliserlalimitepardfautde3



CalculerSLTPenpointspartirdesvaleursUSD

voidCalculateSLTPInPointsENUMPOSITIONTYPEposTypedoubleentryPricedoublesldoubletp

doublelotSize=gpositionTrackercurrentLot>0?gpositionTrackercurrentLot:InitialLotSize;

Calculerlavaleurdupoint
doubletickValue=SymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

SitickValueestendevisedebaseconvertir
doublecontractSize=SymbolInfoDoubleSymbolSYMBOLTRADECONTRACTSIZE;
doublepointValue=tickValuetickSizepoint;

CalculerlespointsncessairespouratteindrelesvaleursUSD
doubleslPoints=0tpPoints=0;

ifpointValue>0lotSize>0

PointspourSL
doubleslValuePerPoint=lotSizepointValue;
ifslValuePerPoint>0
slPoints=StopLossUSDslValuePerPoint;

PointspourTP
doubletpValuePerPoint=lotSizepointValue;
iftpValuePerPoint>0
tpPoints=TakeProfitUSDtpValuePerPoint;


AJOUT:AugmenterleSLde30pointsetleTPde50points
slPoints=30;Ajouter30pointsauSL
tpPoints=50;Ajouter50pointsauTP

ifDebugMode
PrintSLTPajusts:SL30ptsTP50ptsSL=DoubleToStringslPoints1ptsTP=DoubleToStringtpPoints1pts;

SilecalculchoueutiliserdesvaleurspardfautbasessurATR
ifslPoints<=0tpPoints<=0

doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

Utiliser2xATRpourSLet4xATRpourTP
slPoints=20atr[0point;
tpPoints=40atr[0point;

else

Valeurspardfaut
slPoints=50;
tpPoints=100;



CalculerlesprixSLTP
ifposType==POSITIONTYPEBUY

sl=NormalizeDoubleentryPriceslPointspointDigits;
tp=NormalizeDoubleentryPricetpPointspointDigits;

elseSELL

sl=NormalizeDoubleentryPriceslPointspointDigits;
tp=NormalizeDoubleentryPricetpPointspointDigits;


VALIDATIONCRITIQUE:VrifierqueleSLestbienplac
ifposType==POSITIONTYPEBUY

ifsl>=entryPrice

ERREUR:SLaudessusduprixdouverturepourunBUY
ifDebugMode
PrintERREURSLBUY:SLsl>=PrixouvertureentryPriceCorrectionautomatique;
Corriger:SLdoittreendessous
sl=NormalizeDoubleentryPriceslPointspointDigits;
ifsl>=entryPrice

SitoujoursincorrectutiliserATRcommefallback
doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

GESTIONSPCIALEPOURSTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
doubleatrMultiplier=isStepIndex?30:20;PlusgrandpourStepIndex
sl=NormalizeDoubleentryPriceatrMultiplieratr[0Digits;

else
sl=NormalizeDoubleentryPrice50pointDigits;



elseSELL

ifsl<=entryPrice

ERREUR:SLendessousduprixdouverturepourunSELL
ifDebugMode
PrintERREURSLSELL:SLsl<=PrixouvertureentryPriceCorrectionautomatique;
Corriger:SLdoittreaudessus
sl=NormalizeDoubleentryPriceslPointspointDigits;
ifsl<=entryPrice

SitoujoursincorrectutiliserATRcommefallback
doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

GESTIONSPCIALEPOURSTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
doubleatrMultiplier=isStepIndex?30:20;PlusgrandpourStepIndex
sl=NormalizeDoubleentryPriceatrMultiplieratr[0Digits;

else
sl=NormalizeDoubleentryPrice50pointDigits;




CALCULROBUSTEdesniveauxminimumsdubroker
Note:tickValueettickSizesontdjdclarsaudbutdelafonction
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;

CalculerminDistanceenutilisantstopLevelETtickSize
doubleminDistance=stopLevelpoint;

GESTIONSPCIALEPOURSTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
ifisStepIndex

StepIndexncessitedesdistancesminimalesplusgrandes
minDistance=MathMaxminDistance20point;Minimum20pointspourStepIndex
ifDebugMode
PrintStepIndexdtectDistanceminimaleSLTP:DoubleToStringminDistancepoint0points;


SistopLevel=0utiliserunedistanceminimalebasesurletickSize
ifminDistance==0minDistance<tickSize

Utiliseraumoins3tickscommedistanceminimum
minDistance=tickSize3;
ifminDistance==0
minDistance=10point;FallbacksitickSize=0


SassurerqueminDistanceestaumoinsde5pointspourviterleserreurs
ifminDistance<5point
minDistance=5point;

AjusterSLpourrespecterminDistance
doubleslDistance=MathAbsentryPricesl;
ifslDistance<minDistance

ifposType==POSITIONTYPEBUY
sl=NormalizeDoubleentryPriceminDistancepoint2Digits;Ajouterunpeudemarge
else
sl=NormalizeDoubleentryPriceminDistancepoint2Digits;

RecalculerslDistanceaprsajustement
slDistance=MathAbsentryPricesl;


AjusterTPpourrespecterminDistance
doubletpDistance=MathAbstpentryPrice;
iftpDistance<minDistance

ifposType==POSITIONTYPEBUY
tp=NormalizeDoubleentryPriceminDistancepoint2Digits;
else
tp=NormalizeDoubleentryPriceminDistancepoint2Digits;

RecalculertpDistanceaprsajustement
tpDistance=MathAbstpentryPrice;


VALIDATIONFINALEROBUSTE:VrifierqueSLetTPsontcorrectsetvalides
boolslValid=false;
booltpValid=false;

ifposType==POSITIONTYPEBUY

slValid=sl>0sl<entryPriceslDistance>=minDistance;
tpValid=tp>0tp>entryPricetpDistance>=minDistance;

elseSELL

slValid=sl>0sl>entryPriceslDistance>=minDistance;
tpValid=tp>0tp<entryPricetpDistance>=minDistance;


SivalidationchoueutiliserdesvaleursscurisesbasessurATR
ifslValidtpValid

doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

UtiliserATRpourcalculerdesniveauxsrs
doubleatrMultiplierSL=20;
doubleatrMultiplierTP=40;

GESTIONSPCIALEPOURSTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
ifisStepIndex

atrMultiplierSL=30;PlusgrandpourStepIndex
atrMultiplierTP=60;PlusgrandpourStepIndex
ifDebugMode
PrintStepIndexAjustementSLTP:SL=atrMultiplierSLxATRTP=atrMultiplierTPxATR;


ifposType==POSITIONTYPEBUY

sl=NormalizeDoubleentryPriceatrMultiplierSLatr[0Digits;
tp=NormalizeDoubleentryPriceatrMultiplierTPatr[0Digits;

else

sl=NormalizeDoubleentryPriceatrMultiplierSLatr[0Digits;
tp=NormalizeDoubleentryPriceatrMultiplierTPatr[0Digits;


Revrifieraveclesnouvellesvaleurs
slDistance=MathAbsentryPricesl;
tpDistance=MathAbstpentryPrice;

ifslDistance<minDistancetpDistance<minDistance

PrintERREURCRITIQUE:ImpossibledecalculerSLTPvalidesaprscorrectionATRTradeannul;
sl=0;
tp=0;
return;


ifDebugMode
PrintSLTPrecalculsavecATR:SL=slTP=tpminDistance=minDistance;

else

PrintERREURCRITIQUE:SLTPinvalidesetATRindisponibleTradeannul;
sl=0;
tp=0;
return;



DERNIREVRIFICATION:Sassurerquelesvaleurssontnormalisesetvalides
sl=NormalizeDoubleslDigits;
tp=NormalizeDoubletpDigits;

ifsl<=0tp<=0sl==tp

PrintERREURCRITIQUE:SLouTPinvalidesaprsnormalisationTradeannul;
sl=0;
tp=0;




CalculerSLTPenpointsaveclimitedepertemaximale

voidCalculateSLTPInPointsWithMaxLossENUMPOSITIONTYPEposTypedoubleentryPricedoublelotSizedoublemaxLossUSDdoublesldoubletp

Calculerlavaleurdupoint
doubletickValue=SymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

doublepointValue=tickValuetickSizepoint;

Calculerlespointsncessairespourlapertemaximale
doubleslPoints=0tpPoints=0;

ifpointValue>0lotSize>0

doubleslValuePerPoint=lotSizepointValue;
ifslValuePerPoint>0
slPoints=StopLossUSDslValuePerPoint;UtiliserlenouveauparamtreSL

TPstandardaveclenouveauparamtre
doubletpValuePerPoint=lotSizepointValue;
iftpValuePerPoint>0
tpPoints=TakeProfitUSDtpValuePerPoint;UtiliserlenouveauparamtreTP


AJOUT:AugmenterleSLde30pointsetleTPde50points
slPoints=30;Ajouter30pointsauSL
tpPoints=50;Ajouter50pointsauTP

ifDebugMode
PrintSLTPajustsmaxloss:SL30ptsTP50ptsSL=DoubleToStringslPoints1ptsTP=DoubleToStringtpPoints1pts;

SilecalculchoueutiliserdesvaleurspardfautbasessurATR
ifslPoints<=0tpPoints<=0

doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

LimiterSLmaxLossUSD
ifslPoints<=0pointValue>0lotSize>0
slPoints=MathMinmaxLossUSDlotSizepointValue20atr[0point;
iftpPoints<=0
tpPoints=40atr[0point;

else

slPoints=50;
tpPoints=100;



CalculerlesprixSLTP
ifposType==POSITIONTYPEBUY

sl=NormalizeDoubleentryPriceslPointspointDigits;
tp=NormalizeDoubleentryPricetpPointspointDigits;

elseSELL

sl=NormalizeDoubleentryPriceslPointspointDigits;
tp=NormalizeDoubleentryPricetpPointspointDigits;


CALCULROBUSTEdesniveauxminimumsdubrokermmelogiquequeCalculateSLTPInPoints
Note:tickSizeestdjdclaraudbutdelafonction
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=stopLevelpoint;

GESTIONSPCIALEPOURSTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
ifisStepIndex

StepIndexncessitedesdistancesminimalesplusgrandes
minDistance=MathMaxminDistance20point;Minimum20pointspourStepIndex
ifDebugMode
PrintStepIndexdtectDistanceminimaleSLTP:DoubleToStringminDistancepoint0points;


ifminDistance==0minDistance<tickSize

minDistance=tickSize3;
ifminDistance==0
minDistance=10point;


ifminDistance<5point
minDistance=5point;

AjusterSL
doubleslDistance=MathAbsentryPricesl;
ifslDistance<minDistance

ifposType==POSITIONTYPEBUY
sl=NormalizeDoubleentryPriceminDistancepoint2Digits;
else
sl=NormalizeDoubleentryPriceminDistancepoint2Digits;
slDistance=MathAbsentryPricesl;


AjusterTP
doubletpDistance=MathAbstpentryPrice;
iftpDistance<minDistance

ifposType==POSITIONTYPEBUY
tp=NormalizeDoubleentryPriceminDistancepoint2Digits;
else
tp=NormalizeDoubleentryPriceminDistancepoint2Digits;
tpDistance=MathAbstpentryPrice;


Validationfinale
boolslValid=posType==POSITIONTYPEBUY?sl<entryPriceslDistance>=minDistance:sl>entryPriceslDistance>=minDistance;
booltpValid=posType==POSITIONTYPEBUY?tp>entryPricetpDistance>=minDistance:tp<entryPricetpDistance>=minDistance;

ifslValidtpValid

UtiliserATRcommefallback
doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

ifposType==POSITIONTYPEBUY

sl=NormalizeDoubleentryPrice20atr[0Digits;
tp=NormalizeDoubleentryPrice40atr[0Digits;

else

sl=NormalizeDoubleentryPrice20atr[0Digits;
tp=NormalizeDoubleentryPrice40atr[0Digits;


Revrifier
slDistance=MathAbsentryPricesl;
tpDistance=MathAbstpentryPrice;
ifslDistance<minDistancetpDistance<minDistance

sl=0;
tp=0;
return;


else

sl=0;
tp=0;
return;



sl=NormalizeDoubleslDigits;
tp=NormalizeDoubletpDigits;

DERNIREVRIFICATION:SassurerqueSLetTPsontvalides
ifsl<=0tp<=0sl==tp

ifDebugMode
PrintERREUR:SLouTPinvalidesdansCalculateSLTPInPointsWithMaxLossSL=slTP=tp;
sl=0;
tp=0;
return;


VrifierunedernirefoisqueSLestbienplac
ifposType==POSITIONTYPEBUYsl>=entryPrice

ifDebugMode
PrintERREUR:SLBUYinvalideSL=sl>=Entry=entryPrice;
sl=0;
tp=0;
return;

elseifposType==POSITIONTYPESELLsl<=entryPrice

ifDebugMode
PrintERREUR:SLSELLinvalideSL=sl<=Entry=entryPrice;
sl=0;
tp=0;
return;




CalculerSLTPdynamiquespourduplicationavecscurisationgains

voidCalculateDynamicSLTPForDoubleENUMPOSITIONTYPEposTypedoubleopenPricedoublecurrentPricedoublelotSizedoublesecuredProfitdoublemaxDrawdownAlloweddoublesldoubletp

Calculerlavaleurdupoint
doubletickValue=SymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

doublepointValue=tickValuetickSizepoint;

CalculerSLpourscuriserlesgainsviterdeperdreplusdemaxDrawdownAllowed
doubleslPoints=0;
ifpointValue>0lotSize>0securedProfit>0

doubleslValuePerPoint=lotSizepointValue;
ifslValuePerPoint>0
slPoints=maxDrawdownAllowedslValuePerPoint;


SionadjdesgainsleSLdoittreaudessusBUYouendessousSELLduprixdentre
pourscuriseraumoins50desgains
ifsecuredProfit>0slPoints>0

ifposType==POSITIONTYPEBUY

PourBUYSLdoittreaudessusduprixdentrepourscuriserlesgains
sl=NormalizeDoubleopenPriceslPointspointDigits;
SassurerqueleSLestendessousduprixactuel
ifsl>=currentPrice
sl=NormalizeDoublecurrentPricepointDigits;

elseSELL

PourSELLSLdoittreendessousduprixdentrepourscuriserlesgains
sl=NormalizeDoubleopenPriceslPointspointDigits;
SassurerqueleSLestaudessusduprixactuel
ifsl<=currentPrice
sl=NormalizeDoublecurrentPricepointDigits;


else

PasencoredegainsutiliserleSLstandardavecnouveauxparamtres
CalculateSLTPInPointsWithMaxLossposTypecurrentPricelotSizeMaxLossPerPositionsltp;
return;


TPdynamiquebassurleriskrewardavecnouveauTP
doublerisk=MathAbscurrentPricesl;
ifrisk>0

doubleriskRewardRatio=TakeProfitUSDStopLossUSD;Utiliserlesnouveauxparamtres
ifposType==POSITIONTYPEBUY
tp=NormalizeDoublecurrentPriceriskriskRewardRatioDigits;
else
tp=NormalizeDoublecurrentPriceriskriskRewardRatioDigits;

else

FallbacksurTPstandardavecnouveauparamtre
doubletpPoints=TakeProfitUSDlotSizepointValue;
ifposType==POSITIONTYPEBUY
tp=NormalizeDoublecurrentPricetpPointspointDigits;
else
tp=NormalizeDoublecurrentPricetpPointspointDigits;


Vrifierlesniveauxminimumsdubroker
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=stopLevelpoint;
ifminDistance==0minDistance=10point;

ifMathAbscurrentPricesl<minDistance

ifposType==POSITIONTYPEBUY
sl=NormalizeDoublecurrentPriceminDistancepointDigits;
else
sl=NormalizeDoublecurrentPriceminDistancepointDigits;


ifMathAbstpcurrentPrice<minDistance

ifposType==POSITIONTYPEBUY
tp=NormalizeDoublecurrentPriceminDistancepointDigits;
else
tp=NormalizeDoublecurrentPriceminDistancepointDigits;




VrifieretdfinirlerangeUSSessionbougieM515h30Paris

voidDefineUSSessionRange

ifUseUSSessionStrategy
return;

Rinitialisersinouveaujour
MqlDateTimecurrentDtrangeDt;
TimeToStructTimeCurrentcurrentDt;
ifgUSRangeDate>0

TimeToStructgUSRangeDaterangeDt;
ifcurrentDtday=rangeDtdaycurrentDtmon=rangeDtmoncurrentDtyear=rangeDtyear

Nouveaujourrinitialiser
gUSRangeDefined=false;
gUSBreakoutDone=false;
gUSTradeTaken=false;
gUSDirection=0;
gUSRangeDate=0;



ifgUSRangeDefined
return;Djdfiniaujourdhui

DfinirlerangesurlabougieM5de15h30Paris=UTC1enhiverUTC2ent
PoursimplifieronutiliseUTC115h30Paris=14:30UTC
datetimetimeM5[;
ArraySetAsSeriestimeM5true;
ifCopyTimeSymbolPERIODM50100timeM5<=0
return;

forinti=0;i<ArraySizetimeM5;i

MqlDateTimedt;
TimeToStructtimeM5[idt;

ChercherlabougieM5quicorrespond14h3014h34UTC15h3015h34Paris
ifdthour==14dtmin>=30dtmin<=34

doublehighM5[lowM5[;
ArraySetAsSerieshighM5true;
ArraySetAsSerieslowM5true;

ifCopyHighSymbolPERIODM5i1highM5>0CopyLowSymbolPERIODM5i1lowM5>0

gUSHigh=highM5[0;
gUSLow=lowM5[0;
gUSRangeDefined=true;
gUSBreakoutDone=false;
gUSDirection=0;
gUSRangeDate=timeM5[i;

ifDebugMode
PrintUSRANGEDFINI15h30Paris:High=DoubleToStringgUSHighDigitsLow=DoubleToStringgUSLowDigits;

break;






VrifiersionestaprslouvertureUS15h35Paris=14:35UTC

boolIsAfterUSOpening

MqlDateTimedt;
TimeToStructTimeCurrentdt;
14h35UTC=15h35ParisUTC1
ifdthour>14dthour==14dtmin>=35
returntrue;
returnfalse;



DtecterlebreakoutdurangeUS

intDetectUSBreakout

ifgUSRangeDefinedgUSBreakoutDoneIsAfterUSOpening
return0;

doublecloseM1[;
ArraySetAsSeriescloseM1true;
ifCopyCloseSymbolPERIODM101closeM1<=0
return0;

Dtectercassureparlehaut
ifcloseM1[0>gUSHigh

gUSDirection=1;BUY
gUSBreakoutDone=true;
ifDebugMode
PrintBREAKOUTUSDTECTHAUT:Prix=DoubleToStringcloseM1[0Digits>High=DoubleToStringgUSHighDigits;
return1;


Dtectercassureparlebas
ifcloseM1[0<gUSLow

gUSDirection=1;SELL
gUSBreakoutDone=true;
ifDebugMode
PrintBREAKOUTUSDTECTBAS:Prix=DoubleToStringcloseM1[0Digits<Low=DoubleToStringgUSLowDigits;
return1;


return0;



VrifierretestetentrerenpositionUSSession

boolCheckUSRetestAndEnter

ifgUSRangeDefinedgUSBreakoutDonegUSDirection==0
returnfalse;

ifUSOneTradePerDaygUSTradeTaken
returnfalse;

doubleopen[close[high[low[;
ArraySetAsSeriesopentrue;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;

ifCopyOpenSymbolPERIODM101open<=0
CopyCloseSymbolPERIODM101close<=0
CopyHighSymbolPERIODM101high<=0
CopyLowSymbolPERIODM101low<=0
returnfalse;

doubletolerance=USRetestTolerancePoint;

SCNARIOHAUSSIERBUY
ifgUSDirection==1

RetestduniveauhautgUSHigh
ifMathAbslow[0gUSHigh<=tolerance

Confirmation:bougiehaussireclose>open
ifclose[0>open[0

doubleentryPrice=SymbolInfoDoubleSymbolSYMBOLASK;
doublesl=low[0;
doublerisk=entryPricesl;
doubletp=entryPriceriskUSRiskReward;

OuvrirpositionavecSLTPpersonnaliss
ifExecuteUSTradeORDERTYPEBUYentryPricesltp

gUSTradeTaken=true;
ifDebugMode
PrintRETESTUSCONFIRMBUY:Entry=DoubleToStringentryPriceDigitsSL=DoubleToStringslDigitsTP=DoubleToStringtpDigits;
returntrue;





SCNARIOBAISSIERSELL
ifgUSDirection==1

RetestduniveaubasgUSLow
ifMathAbshigh[0gUSLow<=tolerance

Confirmation:bougiebaissireclose<open
ifclose[0<open[0

doubleentryPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doublesl=high[0;
doublerisk=slentryPrice;
doubletp=entryPriceriskUSRiskReward;

OuvrirpositionavecSLTPpersonnaliss
ifExecuteUSTradeORDERTYPESELLentryPricesltp

gUSTradeTaken=true;
ifDebugMode
PrintRETESTUSCONFIRMSELL:Entry=DoubleToStringentryPriceDigitsSL=DoubleToStringslDigitsTP=DoubleToStringtpDigits;
returntrue;





returnfalse;



ExcuteruntradeUSSessionavecSLTPpersonnaliss

boolExecuteUSTradeENUMORDERTYPEorderTypedoubleentryPricedoublesldoubletp

VrificationsdescuritcommeExecuteTrade
doubletotalLoss=GetTotalLoss;
iftotalLoss>=MaxTotalLoss

ifDebugMode
PrintTRADEUSBLOQU:PertetotalemaximaleatteinteDoubleToStringtotalLoss2>=DoubleToStringMaxTotalLoss2;
returnfalse;


PROTECTION:BloquerSELLsurBoometBUYsurCrash
boolisBoom=StringFindSymbolBoom=1;
boolisCrash=StringFindSymbolCrash=1;

ifisBoomorderType==ORDERTYPESELL

ifDebugMode
PrintTRADEUSBLOQU:ImpossibledetraderSELLsurSymbolBoom=BUYuniquement;
returnfalse;


ifisCrashorderType==ORDERTYPEBUY

ifDebugMode
PrintTRADEUSBLOQU:ImpossibledetraderBUYsurSymbolCrash=SELLuniquement;
returnfalse;


Normaliserlelot
doublenormalizedLot=NormalizeLotSizeInitialLotSize;

ifnormalizedLot<SymbolInfoDoubleSymbolSYMBOLVOLUMEMIN

ifDebugMode
PrintLottroppetitpourUSSession:normalizedLot;
returnfalse;


Normaliserlesprix
sl=NormalizeDoubleslDigits;
tp=NormalizeDoubletpDigits;
entryPrice=NormalizeDoubleentryPriceDigits;

Vrifierlesdistancesminimumlogiquerobuste
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doubleminDistance=stopLevelpoint;

ifminDistance==0minDistance<tickSize

minDistance=tickSize3;
ifminDistance==0
minDistance=10point;


ifminDistance<5point
minDistance=5point;

doubleslDistance=MathAbsentryPricesl;
doubletpDistance=MathAbstpentryPrice;

ifslDistance<minDistance

ifDebugMode
PrintDistanceSLinsuffisantepourUSSessionDoubleToStringslDistanceDigits<DoubleToStringminDistanceDigits;
returnfalse;

iftpDistance<minDistance

ifDebugMode
PrintDistanceTPinsuffisantepourUSSessionDoubleToStringtpDistanceDigits<DoubleToStringminDistanceDigits;
returnfalse;


Normaliserlesprixavantouverture
entryPrice=NormalizeDoubleentryPriceDigits;
sl=NormalizeDoubleslDigits;
tp=NormalizeDoubletpDigits;

Validationfinale
ifsl<=0tp<=0sl==tp

ifDebugMode
PrintSLouTPinvalidespourUSSessionSL=slTP=tp;
returnfalse;


iftradePositionOpenSymbolorderTypenormalizedLotentryPricesltpUSSESSIONBREAKRETEST

ifDebugMode
PrintTradeUSSessionouvert:EnumToStringorderTypeLot=normalizedLotEntry=entryPriceSL=slTP=tp;
returntrue;

else

ifDebugMode
PrintErreurouverturetradeUSSession:tradeResultRetcodeDescription;
returnfalse;




Chercheruneopportunitdetrading

voidLookForTradingOpportunity

MODEULTRAPERFORMANCES:Dsactiversitropdecharge
ifHighPerformanceModeDisableAllGraphicsDisableNotifications

ifDebugMode
PrintModesilencieuxultraperformantpasdetrading;
return;Modesilencieuxultraperformant


ifDebugMode
PrintRechercheopportunitsdetradingPositionsactuelles:PositionsTotal;

PRIORIT1:STRATGIEUSSESSIONBREAKRETESTPRIORITAIRE
ifUseUSSessionStrategy

ifDebugMode
PrintStratgieUSSessionactivevrificationconditions;
DefineUSSessionRange;

ifgUSRangeDefinedIsAfterUSOpening

ifgUSBreakoutDone

intbreakout=DetectUSBreakout;
ifbreakout=0

ifDebugMode
PrintBreakoutUSdtectbreakoutattenteretestAUTRESSTRATGIESBLOQUES;
BreakoutdtectattendreretestBLOQUERlesautresstratgies
return;


else

Breakoutfaitchercherretest
ifCheckUSRetestAndEnter

ifDebugMode
PrintTradeUSprissortie;
Tradeprissortir
return;

else

ifDebugMode
PrintEnattenteretestUSAUTRESSTRATGIESBLOQUES;
EnattentederetestBLOQUERlesautresstratgiesjusquauretest
return;



else

ifDebugMode
PrintConditionsUSnonrempliesRangedfini:gUSRangeDefinedAprsouverture:IsAfterUSOpening;


else

ifDebugMode
PrintStratgieUSSessionDSACTIVEautresstratgiesautorises;


PRIORIT2:SIGNALIA
IMPORTANT:letradingnedoitpasdpendredesnotifications
DisableNotifications=truenedoitbloquerletradingquesilutilisateurlesouhaite
boolallowAITrading=UseAIAgentglastAIAction=DisableNotificationsAllowTradingWhenNotificationsDisabled;
ifallowAITrading

ifDebugMode
PrintSignalIAdisponible:glastAIActionconfiance:DoubleToStringglastAIConfidence1;

Dtecterlemodeprudentpertequotidienneleve
boolcautiousMode=gdailyLoss>=MaxDailyLoss;

Seuiladaptatifparsymbole
doublerequiredConfidence=GetRequiredConfidenceForSymbolSymbolcautiousMode;

ifDebugMode

PrintDEBUGGetRequiredConfidenceForSymbol:Symbol>DoubleToStringrequiredConfidence1prudent:cautiousMode;
PrintSeuilconfiancerequis:DoubleToStringrequiredConfidence1Modeprudent:cautiousMode;


RGLESTRICTE:SilIAestactiveTOUJOURSvrifierlaconfianceAVANTdetrader
ifStringCompareglastAIActionhold=0glastAIConfidence>=requiredConfidencegaiFallbackMode

ifDebugMode
PrintSignalIAvalidexcutiondutrade;
DTERMINERLETYPEDESIGNALBASSURLIA
ENUMORDERTYPEsignalType=WRONGVALUE;
ifStringCompareglastAIActionbuy==0
signalType=ORDERTYPEBUY;
elseifStringCompareglastAIActionsell==0
signalType=ORDERTYPESELL;

RGLEBOOMCRASH:pasdeBUYsurCrashpasdeSELLsurBoom
boolisCrashSymbol=StringFindSymbolCrash=1;
boolisBoomSymbol=StringFindSymbolBoom=1;
ifisCrashSymbolsignalType==ORDERTYPEBUY

ifDebugModePrintBLOQU:pasdeBUYsurCrashattentesignalSELL;
return;

ifisBoomSymbolsignalType==ORDERTYPESELL

ifDebugModePrintBLOQU:pasdeSELLsurBoomattentesignalBUY;
return;


SIONAUNSIGNALVALIDEENVOYERNOTIFICATIONETATTENDREENTREPROMETTEUSE
ifsignalType=WRONGVALUE

VrifiersilaflcheDERIVestprsenteconditionrequise
boolhasDerivArrow=IsDerivArrowPresent;

ifhasDerivArrow

Rinitialiserlalistedesordresexcutssincessaire
ResetExecutedOrdersList;

DtectersicestunsymboleBoomCrashpourexcutionspciale
boolisBoomCrashSymbol=StringFindSymbolBoom=1StringFindSymbolCrash=1;

Vrifiersiunordreadjtexcutpourcesymbole
ifHasOrderAlreadyExecutedSymbol

ifDebugMode
PrintOrdredjexcutpourSymbolattentenouvelleopportunit;
return;


TOUJOURSessayerdeplacerunordreLIMITquandlaflcheDERIVestprsente
ifDebugMode
PrintFlcheDERIVdtectePlacementordreLIMITpour:EnumToStringsignalType;

PourBoomCrash:utiliserlastratgieadapteselonlaconfiance
ifisBoomCrashSymbol

SIconfiance80ETflcheDERIVprsenteOrdreMARKETnormal
ifglastAIConfidence>=080hasDerivArrow

ifDebugMode
PrintBoomCrashConfianceleveDoubleToStringglastAIConfidence1FlcheDERIVOrdreMARKETnormal;

ExcuterordremarchavecSLTPadaptspourspike
doubleprice=SymbolInfoDoubleSymbolsignalType==ORDERTYPEBUY?SYMBOLASK:SYMBOLBID;
doubleatrValue=0;
doubleatrBuffer[1;
ifCopyBufferatrHandle001atrBuffer>0
atrValue=atrBuffer[0;
else
atrValue=price0001;

doublestopLoss=0;
doubletakeProfit=0;

ifsignalType==ORDERTYPEBUYBUYsurBoom

stopLoss=NormalizeDoublepriceatrValue08Digits;SLserrpourspike
takeProfit=NormalizeDoublepriceatrValue25Digits;TPrapidepourspike

boolsuccess=tradeBuyNormalizeLotSizeInitialLotSizeSymbolpricestopLosstakeProfit
BOOMMARKETconf:DoubleToStringglastAIConfidence1;

ifsuccess

MarkOrderAsExecutedSymbol;
ifDebugMode
PrintTradeBoomMARKETexcutSL:DoubleToStringstopLossDigitsTP:DoubleToStringtakeProfitDigits;

Notification
ifDisableNotifications

stringnotificationText=BOOMMARKETEXECUTED\nSymbolBUY\nConfiance:DoubleToStringglastAIConfidence1\nSL:DoubleToStringstopLossDigits\nTP:DoubleToStringtakeProfitDigits;
SendNotificationnotificationText;
AlertnotificationText;


else

ifDebugMode
PrintErreurtradeBoomMARKET:tradeResultRetcodetradeResultRetcodeDescription;


elseSELLsurCrash

stopLoss=NormalizeDoublepriceatrValue08Digits;SLserrpourspike
takeProfit=NormalizeDoublepriceatrValue25Digits;TPrapidepourspike

boolsuccess=tradeSellNormalizeLotSizeInitialLotSizeSymbolpricestopLosstakeProfit
CRASHMARKETconf:DoubleToStringglastAIConfidence1;

ifsuccess

MarkOrderAsExecutedSymbol;
ifDebugMode
PrintTradeCrashMARKETexcutSL:DoubleToStringstopLossDigitsTP:DoubleToStringtakeProfitDigits;

Notification
ifDisableNotifications

stringnotificationText=CRASHMARKETEXECUTED\nSymbolSELL\nConfiance:DoubleToStringglastAIConfidence1\nSL:DoubleToStringstopLossDigits\nTP:DoubleToStringtakeProfitDigits;
SendNotificationnotificationText;
AlertnotificationText;


else

ifDebugMode
PrintErreurtradeCrashMARKET:tradeResultRetcodetradeResultRetcodeDescription;


return;Sortiraprsexcutionmarch

else

SINONOrdreLIMITpourcapturerspikelogiqueexistante
ifDebugMode
PrintBoomCrashPlacementordreLIMITpourcapturerspikeDoubleToStringglastAIConfidence1;

CalculerSLTPadaptspourBoomCrash
doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doubleatrValue=0;
doubleatrBuffer[1;
ifCopyBufferatrHandle001atrBuffer>0
atrValue=atrBuffer[0;
else
atrValue=currentPrice0001;

doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doublestopLoss=0;
doubletakeProfit=0;
doubleentryPrice=0;

ifsignalType==ORDERTYPEBUYBUYsurBoom

PlacerBUYLIMITsousleprixactuelpourcapturerlespikebaissier
entryPrice=currentPriceatrValue03;30dATRsousleprix
stopLoss=entryPriceatrValue05;SLtrsserr
takeProfit=entryPriceatrValue20;TPrapidepourspike

elseSELLsurCrash

PlacerSELLLIMITaudessusduprixactuelpourcapturerlespikehaussier
entryPrice=currentPriceatrValue03;30dATRaudessusduprix
stopLoss=entryPriceatrValue05;SLtrsserr
takeProfit=entryPriceatrValue20;TPrapidepourspike


Vrifierlesdistancesminimales
doubleminDistance=MathMax20pointatrValue02;
doubleslDistance=MathAbsentryPricestopLoss;
doubletpDistance=MathAbstakeProfitentryPrice;

ifslDistance<minDistancetpDistance<minDistance

ifDebugMode
PrintDistancesSLTPtropfaiblespourBoomCrashLIMIT;
return;


Tailledepositionadapte
doublelotSize=InitialLotSize;
ifglastAIConfidence>=095
lotSize=InitialLotSize15;
elseifglastAIConfidence>=090
lotSize=InitialLotSize12;

lotSize=NormalizeLotSizelotSize;

PlacerlordreLIMIT
ENUMORDERTYPEpendingType=GetPendingTypeFromSignalsignalType;
stringpendingTypeStr=pendingType==ORDERTYPEBUYLIMIT?BUYLIMIT:SELLLIMIT;
stringorderComment=BoomCrashLIMITSPIKEpendingTypeStrconf:DoubleToStringglastAIConfidence1;

ifEnsureStopsDistanceValidentryPricependingTypestopLosstakeProfit

boolsuccess=false;
ifsignalType==ORDERTYPEBUY

success=tradeBuyLimitlotSizeSymbolentryPricestopLosstakeProfitORDERTIMEGTC0orderComment;

elseSELL

success=tradeSellLimitlotSizeSymbolentryPricestopLosstakeProfitORDERTIMEGTC0orderComment;


ifsuccess

doubleriskUSD=slDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=tpDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintORDRELIMITBOOMCRASHPLACPOURSPIKE:;
PrintType:EnumToStringpendingType;
PrintEntre:DoubleToStringentryPriceDigits;
PrintSL:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTP:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;
PrintTaille:DoubleToStringlotSize2;
PrintConfiance:DoubleToStringglastAIConfidence1;
PrintStratgie:LIMITpourcapturerspikeBoomCrash;

Envoyernotification
ifDisableNotifications

stringnotificationText=BOOMCRASHLIMITSPIKE\nSymbolEnumToStringpendingType
\n@DoubleToStringentryPriceDigits
\nConfiance:DoubleToStringglastAIConfidence1;
SendNotificationnotificationText;
AlertnotificationText;


Marquercommeexcut
MarkOrderAsExecutedSymbol;
return;

else

PrintErreurplacementordreLIMITBoomCrash:tradeResultRetcodetradeResultRetcodeDescription;



else

Pourlesautressymboles:placerordreLIMITprsdelarsistancesupportlaplusproche
ifDebugMode
PrintSymbolenormalPlacementordreLIMITprssupportrsistance;

UtiliserlafonctionexistantepourplacerlordreLIMIT
ifPlaceLimitOrderOnArrowsignalType

MarkOrderAsExecutedSymbol;
stringsignalText=SIGNALIADTECT:glastAIAction==buy?BUY:SELLconfiance:DoubleToStringglastAIConfidence1;
signalText=\nFlcheDERIVprsente;
signalText=\nOrdreLIMITplacavecsuccs;

ifDebugMode
PrintOrdrelimitplacdsdtectionflcheType:EnumToStringsignalType;

else

ifDebugMode
PrintCHECplacementordreLIMITpourEnumToStringsignalType;









VrifiersilaflcheDERIVestprsentesurlegraphique

boolIsDerivArrowPresent

Chercherlesobjetsflchesurlegraphique
forinti=ObjectsTotal01;i>=0;i

stringobjName=ObjectName0i;
ifStringFindobjNameArrow=1StringFindobjNameDERIV=1
StringFindobjNamederiv=1StringFindobjNamearrow=1

ifDebugMode
PrintFlcheDERIVdtecte:objName;
returntrue;



Siaucuneflchetrouvevrifierlesobjetstextespcifiques
forinti=ObjectsTotal01;i>=0;i

stringobjName=ObjectName0i;
ifStringFindobjNameBUY=1StringFindobjNameSELL=1
StringFindobjNameACHAT=1StringFindobjNameVENTE=1

ifDebugMode
PrintSignaltextedtect:objName;
returntrue;



returnfalse;



AmliorerlavalidationdesdistancesSLTP

boolEnsureStopsDistanceValiddoubleentryPriceENUMORDERTYPEpendingTypedoublesldoubletp

doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
longstopLevelPoints=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=stopLevelPointspoint;

Augmenterladistanceminimalepourviterleserreurs
ifminDistance<10pointminDistance=10point;

Pourcertainssymbolessynthtiquesonforceunpeuplusdcart
ifIsVolatilitySymbolSymbolStringFindSymbolBoom=1StringFindSymbolCrash=1
minDistance=MathMaxminDistance20point;

doubleslDist=MathAbsentryPricesl;
doubletpDist=MathAbstpentryPrice;

Vrifieretcorrigerlesdistancessincessaire
ifslDist<minDistance

ifDebugMode
PrintSLtropproche:DoubleToStringslDistpoint0points<minimum:DoubleToStringminDistancepoint0points;

AjusterleSLpourrespecterladistanceminimale
ifpendingType==ORDERTYPEBUYLIMIT

sl=NormalizeDoubleentryPriceminDistance2pointDigits;
tp=NormalizeDoubleentryPriceLimitRRentryPriceslDigits;

elseifpendingType==ORDERTYPESELLLIMIT

sl=NormalizeDoubleentryPriceminDistance2pointDigits;
tp=NormalizeDoubleentryPriceLimitRRslentryPriceDigits;

else

returnfalse;


Recalculerlesdistancesaprsajustement
slDist=MathAbsentryPricesl;
tpDist=MathAbstpentryPrice;


iftpDist<minDistance

ifDebugMode
PrintTPtropproche:DoubleToStringtpDistpoint0points<minimum:DoubleToStringminDistancepoint0points;

AjusterleTPpourrespecterladistanceminimale
ifpendingType==ORDERTYPEBUYLIMIT

tp=NormalizeDoubleentryPriceMathMaxminDistance2pointLimitRRslDistDigits;

elseifpendingType==ORDERTYPESELLLIMIT

tp=NormalizeDoubleentryPriceMathMaxminDistance2pointLimitRRslDistDigits;

else

returnfalse;


tpDist=MathAbstpentryPrice;


Vrificationfinale
boolisValid=slDist>=minDistancetpDist>=minDistancesl>0tp>0sl=tp;

ifisValidDebugMode

PrintDistancesSLTPinvalidesaprsajustement:;
PrintSLDistance:DoubleToStringslDistpoint0pointsmin:DoubleToStringminDistancepoint0;
PrintTPDistance:DoubleToStringtpDistpoint0pointsmin:DoubleToStringminDistancepoint0;
PrintEntry:DoubleToStringentryPriceDigits;
PrintSL:DoubleToStringslDigits;
PrintTP:DoubleToStringtpDigits;


returnisValid;



Normaliserlelotselonlesspcificationsdubroker

doubleNormalizeLotSizedoublelot

doubleminLot=SymbolInfoDoubleSymbolSYMBOLVOLUMEMIN;
doublemaxLot=SymbolInfoDoubleSymbolSYMBOLVOLUMEMAX;
doublelotStep=SymbolInfoDoubleSymbolSYMBOLVOLUMESTEP;

Normaliserselonlestep
lot=MathFloorlotlotSteplotStep;

Limiterauxbornes
lot=MathMaxminLotMathMinmaxLotlot;

returnlot;



Vrifiesicestunsymboledevolatilit

boolIsVolatilitySymbolconststringsymbol

returnStringFindsymbolVolatility=1
StringFindsymbolBOOM=1
StringFindsymbolCRASH=1
StringFindsymbolStep=1;



DtecteunepaireForexclassique

boolIsForexSymbolconststringsymbol

ExclureBoomCrashVolatilityStep
ifIsVolatilitySymbolsymbol
StringFindsymbolBoom=1
StringFindsymbolCrash=1
returnfalse;

SilesymbolecontientaumoinsundesprincipauxcodesdevisesonletraitecommeForex
ifStringFindsymbolEUR=1StringFindsymbolGBP=1
StringFindsymbolUSD=1StringFindsymbolJPY=1
StringFindsymbolAUD=1StringFindsymbolCAD=1
StringFindsymbolCHF=1StringFindsymbolNZD=1
returntrue;

returnfalse;



Comptelenombredesymbolesactifsavecpositionsouvertes

intCountActiveSymbols

stringactiveSymbols[;
intsymbolCount=0;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoMagic==InpMagicNumber

stringsymbol=positionInfoSymbol;

Vrifiersicesymbolenestpasdjdanslaliste
boolfound=false;
forintj=0;j<symbolCount;j

ifactiveSymbols[j==symbol

found=true;
break;



iffound

ArrayResizeactiveSymbolssymbolCount1;
activeSymbols[symbolCount=symbol;
symbolCount;





returnsymbolCount;



Comptelespositionspourlesymboleactuel

intCountPositionsForSymbolMagic

intcnt=0;
forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoMagic==InpMagicNumberpositionInfoSymbol==Symbol
cnt;


returncnt;



Vrifiesiunepositiondummetypeexistedj
NOTE:LaduplicationneconcernePASlesBoomCrash
Ellesappliqueuniquementauxindicesvolatilitystepindexetforex

boolHasDuplicatePositionENUMORDERTYPEorderType

LaduplicationneconcernePASlesBoomCrash
Ellesappliqueuniquementauxindicesvolatilitystepindexetforex
boolisBoomCrash=StringFindSymbolBoom=1StringFindSymbolCrash=1;
ifisBoomCrash
returnfalse;PasdevrificationdeduplicationpourBoomCrash

Vrifieruniquementpourvolatilitystepindexetforex
boolisVolatility=IsVolatilitySymbolSymbol;
boolisStepIndex=StringFindSymbolStep=1StringFindSymbolStepIndex=1;
boolisForex=IsForexSymbolSymbol;

ifisVolatilityisStepIndexisForex
returnfalse;Pasdevrificationpourlesautrestypes

NOUVEAU:Vrifierlalignementdesendpointspourladuplication
boolallowDuplication=true;
ifUseAllEndpointsRequireAllEndpointsAlignment

Silalignementestrequisvrifierquilestsuffisant
allowDuplication=gendpointsAlignment>=075;75minimumpourdupliquer

ifDebugModeallowDuplication
PrintDUPLICATIONBLOQUE:Alignementendpointsinsuffisant
DoubleToStringgendpointsAlignment1001<75;


forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoMagic==InpMagicNumberpositionInfoSymbol==Symbol

ENUMPOSITIONTYPEposType=ENUMPOSITIONTYPEpositionInfoPositionType;
iforderType==ORDERTYPEBUYposType==POSITIONTYPEBUY
orderType==ORDERTYPESELLposType==POSITIONTYPESELL

Sionaunepositiondummetypevrifierlalignement
ifallowDuplication

ifDebugMode
PrintDUPLICATIONBLOQUE:PositionEnumToStringorderType
djexistanteetalignementendpointsinsuffisant;
returntrue;Bloquerladuplication

else

ifDebugMode
PrintDUPLICATIONAUTORISE:PositionEnumToStringorderType
djexistantemaisalignementendpointssuffisant
DoubleToStringgendpointsAlignment1001;

returntrue;Positiondummetypedjouverte




returnfalse;



Calculerlapertetotaledetouteslespositionsactives

doubleGetTotalLoss

doubletotalLoss=00;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoMagic==InpMagicNumber

doubleprofit=positionInfoProfit;
ifprofit<0Seulementlespertes
totalLoss=MathAbsprofit;




returntotalLoss;





VrifierlalignementdetendanceM5etH1

boolCheckTrendAlignmentENUMORDERTYPEorderType

NOUVEAU:VrifierdabordlAPIdetendancesiactive
ifUseTrendAPIAnalysisgapitrendvalid

VrifiersiladirectiondelAPIcorrespondausignal
boolapiAligned=false;
iforderType==ORDERTYPEBUYgapitrenddirection==1
apiAligned=true;
elseiforderType==ORDERTYPESELLgapitrenddirection==1
apiAligned=true;

ifapiAligned

ifDebugMode

stringapiDir=gapitrenddirection==1?BUY:gapitrenddirection==1?SELL:NEUTRE;
PrintAPITrendnonaligne:Signal=EnumToStringorderTypeAPI=apiDirConfiance:DoubleToStringgapitrendconfidence1;

returnfalse;APIdetendancenonalignebloquerletrade


ifDebugMode

stringapiDir=gapitrenddirection==1?BUY:gapitrenddirection==1?SELL:NEUTRE;
PrintAPITrendaligne:apiDirConfiance:DoubleToStringgapitrendconfidence1Force:DoubleToStringgapitrendstrength1;



doubleemaFastM5[emaSlowM5[emaFastH1[emaSlowH1[;
ArraySetAsSeriesemaFastM5true;
ArraySetAsSeriesemaSlowM5true;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;

ifCopyBufferemaFastM5Handle001emaFastM5<=0
CopyBufferemaSlowM5Handle001emaSlowM5<=0
CopyBufferemaFastH1Handle001emaFastH1<=0
CopyBufferemaSlowH1Handle001emaSlowH1<=0

ifDebugMode
PrintErreurrcuprationindicateursM5H1;
returnfalse;


VrifierlalignementpourBUY
iforderType==ORDERTYPEBUY

boolm5Bullish=emaFastM5[0>emaSlowM5[0;
boolh1Bullish=emaFastH1[0>emaSlowH1[0;

ifm5Bullishh1Bullish

ifDebugMode
PrintAlignementhaussierconfirm:M5=m5Bullish?UP:DOWNH1=h1Bullish?UP:DOWN;
returntrue;

else

ifDebugMode
PrintAlignementhaussiernonconfirm:M5=m5Bullish?UP:DOWNH1=h1Bullish?UP:DOWN;
returnfalse;


VrifierlalignementpourSELL
elseiforderType==ORDERTYPESELL

boolm5Bearish=emaFastM5[0<emaSlowM5[0;
boolh1Bearish=emaFastH1[0<emaSlowH1[0;

ifm5Bearishh1Bearish

ifDebugMode
PrintAlignementbaissierconfirm:M5=m5Bearish?DOWN:UPH1=h1Bearish?DOWN:UP;
returntrue;

else

ifDebugMode
PrintAlignementbaissiernonconfirm:M5=m5Bearish?DOWN:UPH1=h1Bearish?DOWN:UP;
returnfalse;



returnfalse;



DessinerlesniveauxdesupportrsistanceM1M5etH1

voidDrawSupportResistanceLevels

doubleatrM1[atrM5[atrH1[;
ArraySetAsSeriesatrM1true;
ArraySetAsSeriesatrM5true;
ArraySetAsSeriesatrH1true;

ifCopyBufferatrM1Handle001atrM1<=0
CopyBufferatrM5Handle001atrM5<=0
CopyBufferatrH1Handle001atrH1<=0
return;

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;

SupportRsistanceM1courtterme
doublesupportM1=currentPrice15atrM1[0;
doubleresistanceM1=currentPrice15atrM1[0;

SupportRsistanceM5moyenterme
doublesupportM5=currentPrice20atrM5[0;
doubleresistanceM5=currentPrice20atrM5[0;

SupportRsistanceH1longterme
doublesupportH1=currentPrice25atrH1[0;
doubleresistanceH1=currentPrice25atrH1[0;

===SUPPORTSRESISTANCESM1===
SupportM1vertclair
stringsupportM1Name=SRSupportM1Symbol;
ifObjectFind0supportM1Name<0
ObjectCreate0supportM1NameOBJHLINE00supportM1;
else
ObjectSetDouble0supportM1NameOBJPROPPRICEsupportM1;
ObjectSetInteger0supportM1NameOBJPROPCOLORclrLime;
ObjectSetInteger0supportM1NameOBJPROPSTYLESTYLEDOT;
ObjectSetInteger0supportM1NameOBJPROPWIDTH1;
ObjectSetString0supportM1NameOBJPROPTEXTSupportM1;
ObjectSetInteger0supportM1NameOBJPROPBACK1;

RsistanceM1orangeclair
stringresistanceM1Name=SRResistanceM1Symbol;
ifObjectFind0resistanceM1Name<0
ObjectCreate0resistanceM1NameOBJHLINE00resistanceM1;
else
ObjectSetDouble0resistanceM1NameOBJPROPPRICEresistanceM1;
ObjectSetInteger0resistanceM1NameOBJPROPCOLORclrOrange;
ObjectSetInteger0resistanceM1NameOBJPROPSTYLESTYLEDOT;
ObjectSetInteger0resistanceM1NameOBJPROPWIDTH1;
ObjectSetString0resistanceM1NameOBJPROPTEXTRsistanceM1;
ObjectSetInteger0resistanceM1NameOBJPROPBACK1;

===SUPPORTSRESISTANCESM5===
SupportM5bleu
stringsupportM5Name=SRSupportM5Symbol;
ifObjectFind0supportM5Name<0
ObjectCreate0supportM5NameOBJHLINE00supportM5;
else
ObjectSetDouble0supportM5NameOBJPROPPRICEsupportM5;
ObjectSetInteger0supportM5NameOBJPROPCOLORclrBlue;
ObjectSetInteger0supportM5NameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0supportM5NameOBJPROPWIDTH1;
ObjectSetString0supportM5NameOBJPROPTEXTSupportM5;
ObjectSetInteger0supportM5NameOBJPROPBACK1;

RsistanceM5rouge
stringresistanceM5Name=SRResistanceM5Symbol;
ifObjectFind0resistanceM5Name<0
ObjectCreate0resistanceM5NameOBJHLINE00resistanceM5;
else
ObjectSetDouble0resistanceM5NameOBJPROPPRICEresistanceM5;
ObjectSetInteger0resistanceM5NameOBJPROPCOLORclrRed;
ObjectSetInteger0resistanceM5NameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0resistanceM5NameOBJPROPWIDTH1;
ObjectSetString0resistanceM5NameOBJPROPTEXTRsistanceM5;
ObjectSetInteger0resistanceM5NameOBJPROPBACK1;

===SUPPORTSRESISTANCESH1===
SupportH1bleufoncplusimportant
stringsupportH1Name=SRSupportH1Symbol;
ifObjectFind0supportH1Name<0
ObjectCreate0supportH1NameOBJHLINE00supportH1;
else
ObjectSetDouble0supportH1NameOBJPROPPRICEsupportH1;
ObjectSetInteger0supportH1NameOBJPROPCOLORclrDodgerBlue;
ObjectSetInteger0supportH1NameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0supportH1NameOBJPROPWIDTH2;
ObjectSetString0supportH1NameOBJPROPTEXTSupportH1;
ObjectSetInteger0supportH1NameOBJPROPBACK0;

RsistanceH1rougefoncplusimportant
stringresistanceH1Name=SRResistanceH1Symbol;
ifObjectFind0resistanceH1Name<0
ObjectCreate0resistanceH1NameOBJHLINE00resistanceH1;
else
ObjectSetDouble0resistanceH1NameOBJPROPPRICEresistanceH1;
ObjectSetInteger0resistanceH1NameOBJPROPCOLORclrCrimson;
ObjectSetInteger0resistanceH1NameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0resistanceH1NameOBJPROPWIDTH2;
ObjectSetString0resistanceH1NameOBJPROPTEXTRsistanceH1;
ObjectSetInteger0resistanceH1NameOBJPROPBACK0;

ifDebugMode
PrintSupportsRsistancesmisjourM1:DoubleToStringsupportM1DigitsDoubleToStringresistanceM1Digits
M5:DoubleToStringsupportM5DigitsDoubleToStringresistanceM5Digits
H1:DoubleToStringsupportH1DigitsDoubleToStringresistanceH1Digits;



DessinerleszonesBUYSELLdelIArectanglesnonremplis

voidDrawAIZonesOnChart

ifDrawAIZones

SupprimertoutesleszonesAIH8H1M5
ObjectDelete0AIBUYZONEH8Symbol;
ObjectDelete0AISELLZONEH8Symbol;
ObjectDelete0AIBUYZONEH1Symbol;
ObjectDelete0AISELLZONEH1Symbol;
ObjectDelete0AIBUYZONEM5Symbol;
ObjectDelete0AISELLZONEM5Symbol;
return;


datetimenow=TimeCurrent;

Couleurstransparentesvertetrougeavecalpha
colorbuyColor=C0255050;Verttransparentalpha=50
colorsellColor=C2550050;Rougetransparentalpha=50

Timeframestracer:H8H1M5
ENUMTIMEFRAMEStimeframes[;
ArrayResizetimeframes3;
timeframes[0=PERIODH8;
timeframes[1=PERIODH1;
timeframes[2=PERIODM5;

stringtfNames[;
ArrayResizetfNames3;
tfNames[0=H8;
tfNames[1=H1;
tfNames[2=M5;

Tracerleszonespourchaquetimeframe
forinttfIdx=0;tfIdx<ArraySizetimeframes;tfIdx

ENUMTIMEFRAMEStf=timeframes[tfIdx;
stringtfName=tfNames[tfIdx;

Calculerleslimitestemporellesselonletimeframe
intperiodSeconds=PeriodSecondstf;
datetimepast=now200periodSeconds;200bougiesenarrire
datetimefuture=now50periodSeconds;50bougiesenavant

ZoneBUYRectanglerempliaveccouleurtransparente
stringbuyZoneName=AIBUYZONEtfNameSymbol;
ifgaiBuyZoneLow>00gaiBuyZoneHigh>00gaiBuyZoneHigh>gaiBuyZoneLow

ifObjectFind0buyZoneName<0
ObjectCreate0buyZoneNameOBJRECTANGLE0pastgaiBuyZoneHighfuturegaiBuyZoneLow;
else

ObjectSetDouble0buyZoneNameOBJPROPPRICE0gaiBuyZoneHigh;
ObjectSetDouble0buyZoneNameOBJPROPPRICE1gaiBuyZoneLow;
ObjectSetInteger0buyZoneNameOBJPROPTIME0past;
ObjectSetInteger0buyZoneNameOBJPROPTIME1future;


Couleurtransparenteverterempli
ObjectSetInteger0buyZoneNameOBJPROPCOLORbuyColor;
ObjectSetInteger0buyZoneNameOBJPROPBACK1;Enarrireplan
ObjectSetInteger0buyZoneNameOBJPROPFILL1;REMPLIavectransparence
ObjectSetInteger0buyZoneNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0buyZoneNameOBJPROPWIDTH1;
ObjectSetInteger0buyZoneNameOBJPROPSELECTABLEfalse;
Afficheruniquementsurletimeframecorrespondant
ObjectSetInteger0buyZoneNameOBJPROPTIMEFRAMES1<<inttf;

else

ObjectDelete0buyZoneName;


ZoneSELLRectanglerempliaveccouleurtransparente
stringsellZoneName=AISELLZONEtfNameSymbol;
ifgaiSellZoneLow>00gaiSellZoneHigh>00gaiSellZoneHigh>gaiSellZoneLow

ifObjectFind0sellZoneName<0
ObjectCreate0sellZoneNameOBJRECTANGLE0pastgaiSellZoneHighfuturegaiSellZoneLow;
else

ObjectSetDouble0sellZoneNameOBJPROPPRICE0gaiSellZoneHigh;
ObjectSetDouble0sellZoneNameOBJPROPPRICE1gaiSellZoneLow;
ObjectSetInteger0sellZoneNameOBJPROPTIME0past;
ObjectSetInteger0sellZoneNameOBJPROPTIME1future;


Couleurtransparenterougerempli
ObjectSetInteger0sellZoneNameOBJPROPCOLORsellColor;
ObjectSetInteger0sellZoneNameOBJPROPBACK1;Enarrireplan
ObjectSetInteger0sellZoneNameOBJPROPFILL1;REMPLIavectransparence
ObjectSetInteger0sellZoneNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0sellZoneNameOBJPROPWIDTH1;
ObjectSetInteger0sellZoneNameOBJPROPSELECTABLEfalse;
Afficheruniquementsurletimeframecorrespondant
ObjectSetInteger0sellZoneNameOBJPROPTIMEFRAMES1<<inttf;

else

ObjectDelete0sellZoneName;





DessinerlestrendlinesbasessurlesEMAM5etH1
Depuislhistoriquede1000bougies

voidDrawTrendlinesOnChart

ifDrawTrendlines
return;

Rcuprer1000bougiesdhistoriquepourM5
doubleemaFastM5[emaSlowM5[;
datetimetimeM5[;
ArraySetAsSeriesemaFastM5true;
ArraySetAsSeriesemaSlowM5true;
ArraySetAsSeriestimeM5true;

intcountM5=1000;
ifCopyBufferemaFastM5Handle00countM5emaFastM5<=0
CopyBufferemaSlowM5Handle00countM5emaSlowM5<=0

ifDebugMode
PrintErreurrcuprationEMAM5pourtrendlines;
return;


RcuprerlestimestampsM5passsfutures
datetimetimeM5Past[timeM5Future[;
ArraySetAsSeriestimeM5Pasttrue;
ArraySetAsSeriestimeM5Futuretrue;

1000bougiespassesM5
ifCopyTimeSymbolPERIODM501000timeM5Past<=0

ifDebugMode
PrintErreurrcuprationtimestampsM5passs;
return;


Crer1000timestampsfutursM5projection
datetimelastTimeM5=timeM5Past[999;
ArrayResizetimeM5Future1000;
forinti=0;i<1000;i

timeM5Future[i=lastTimeM5i1PeriodSecondsPERIODM5;


CombinerlesdeuxarraysM5
ArrayResizetimeM52000;
forinti=0;i<1000;i
timeM5[i=timeM5Past[i;
forinti=0;i<1000;i
timeM5[1000i=timeM5Future[i;

tendrelesarraysEMAM5pourinclurelesprojectionsfutures
ArrayResizeemaFastM52000;
ArrayResizeemaSlowM52000;

ProjeterlesEMAM5danslefutur
doubleemaFastM5Slope=emaFastM5[999emaFastM5[9001000;
doubleemaSlowM5Slope=emaSlowM5[999emaSlowM5[9001000;

forinti=1000;i<2000;i

emaFastM5[i=emaFastM5[999i999emaFastM5Slope;
emaSlowM5[i=emaSlowM5[999i999emaSlowM5Slope;


Rcuprer1000bougiesdhistoriquepourH1
doubleemaFastH1[emaSlowH1[;
datetimetimeH1[;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;
ArraySetAsSeriestimeH1true;

intcountH1=1000;
ifCopyBufferemaFastH1Handle00countH1emaFastH1<=0
CopyBufferemaSlowH1Handle00countH1emaSlowH1<=0

ifDebugMode
PrintErreurrcuprationEMAH1pourtrendlines;
return;


RcuprerlestimestampsH1passsfutures
datetimetimeH1Past[timeH1Future[;
ArraySetAsSeriestimeH1Pasttrue;
ArraySetAsSeriestimeH1Futuretrue;

1000bougiespassesH1
ifCopyTimeSymbolPERIODH101000timeH1Past<=0

ifDebugMode
PrintErreurrcuprationtimestampsH1passs;
return;


Crer1000timestampsfutursH1projection
datetimelastTimeH1=timeH1Past[999;
ArrayResizetimeH1Future1000;
forinti=0;i<1000;i

timeH1Future[i=lastTimeH1i1PeriodSecondsPERIODH1;


CombinerlesdeuxarraysH1
ArrayResizetimeH12000;
forinti=0;i<1000;i
timeH1[i=timeH1Past[i;
forinti=0;i<1000;i
timeH1[1000i=timeH1Future[i;

tendrelesarraysEMAH1pourinclurelesprojectionsfutures
ArrayResizeemaFastH12000;
ArrayResizeemaSlowH12000;

ProjeterlesEMAH1danslefutur
doubleemaFastH1Slope=emaFastH1[999emaFastH1[9001000;
doubleemaSlowH1Slope=emaSlowH1[999emaSlowH1[9001000;

forinti=1000;i<2000;i

emaFastH1[i=emaFastH1[999i999emaFastH1Slope;
emaSlowH1[i=emaSlowH1[999i999emaSlowH1Slope;


TrouverlespointsdedbutetfinpourM5maintenant2000points
AvecArraySetAsSeries=trueindex0=laplusrcenteindex1999=laplusanciennefuture
intstartM5=1endM5=1;

Trouverlapremirevaleurvalidelaplusrcenteindex0
forinti=0;i<2000;i

ifemaFastM5[i>0emaSlowM5[i>0

ifendM5==1endM5=i;Premirevaleurvalidetrouvelaplusrcente



Trouverladernirevaleurvalidelaplusancienne
forinti=1999;i>=0;i

ifemaFastM5[i>0emaSlowM5[i>0

startM5=i;Dernirevaleurvalidelaplusancienne
break;



TrouverlespointsdedbutetfinpourH1maintenant2000points
intstartH1=1endH1=1;

Trouverlapremirevaleurvalidelaplusrcente
forinti=0;i<2000;i

ifemaFastH1[i>0emaSlowH1[i>0

ifendH1==1endH1=i;Premirevaleurvalidetrouvelaplusrcente



Trouverladernirevaleurvalidelaplusancienne
forinti=1999;i>=0;i

ifemaFastH1[i>0emaSlowH1[i>0

startH1=i;Dernirevaleurvalidelaplusancienne
break;



DessinertrendlineEMAFastM5dupointleplusancienauplusrcent
ifstartM5>=0endM5>=0startM5<2000endM5<2000startM5=endM5

stringtrendFastM5=TrendEMAFastM5Symbol;
ifObjectFind0trendFastM5<0
ObjectCreate0trendFastM5OBJTREND0timeM5[startM5emaFastM5[startM5timeM5[endM5emaFastM5[endM5;
else

ObjectSetInteger0trendFastM5OBJPROPTIME0timeM5[startM5;
ObjectSetDouble0trendFastM5OBJPROPPRICE0emaFastM5[startM5;
ObjectSetInteger0trendFastM5OBJPROPTIME1timeM5[endM5;
ObjectSetDouble0trendFastM5OBJPROPPRICE1emaFastM5[endM5;

ObjectSetInteger0trendFastM5OBJPROPCOLORclrDodgerBlue;
ObjectSetInteger0trendFastM5OBJPROPSTYLESTYLEDASH;
ObjectSetInteger0trendFastM5OBJPROPWIDTH2;
ObjectSetInteger0trendFastM5OBJPROPRAYRIGHTtrue;
ObjectSetInteger0trendFastM5OBJPROPRAYLEFTfalse;
ObjectSetInteger0trendFastM5OBJPROPSELECTABLEfalse;
ObjectSetString0trendFastM5OBJPROPTEXTEMAFastM5;


DessinertrendlineEMASlowM5
ifstartM5>=0endM5>=0startM5<2000endM5<2000startM5=endM5

stringtrendSlowM5=TrendEMASlowM5Symbol;
ifObjectFind0trendSlowM5<0
ObjectCreate0trendSlowM5OBJTREND0timeM5[startM5emaSlowM5[startM5timeM5[endM5emaSlowM5[endM5;
else

ObjectSetInteger0trendSlowM5OBJPROPTIME0timeM5[startM5;
ObjectSetDouble0trendSlowM5OBJPROPPRICE0emaSlowM5[startM5;
ObjectSetInteger0trendSlowM5OBJPROPTIME1timeM5[endM5;
ObjectSetDouble0trendSlowM5OBJPROPPRICE1emaSlowM5[endM5;

ObjectSetInteger0trendSlowM5OBJPROPCOLORclrOrange;
ObjectSetInteger0trendSlowM5OBJPROPSTYLESTYLEDASH;
ObjectSetInteger0trendSlowM5OBJPROPWIDTH2;
ObjectSetInteger0trendSlowM5OBJPROPRAYRIGHTtrue;
ObjectSetInteger0trendSlowM5OBJPROPRAYLEFTfalse;
ObjectSetInteger0trendSlowM5OBJPROPSELECTABLEfalse;
ObjectSetString0trendSlowM5OBJPROPTEXTEMASlowM5;


DessinertrendlineEMAFastH1
ifstartH1>=0endH1>=0startH1<2000endH1<2000startH1=endH1

stringtrendFastH1=TrendEMAFastH1Symbol;
ifObjectFind0trendFastH1<0
ObjectCreate0trendFastH1OBJTREND0timeH1[startH1emaFastH1[startH1timeH1[endH1emaFastH1[endH1;
else

ObjectSetInteger0trendFastH1OBJPROPTIME0timeH1[startH1;
ObjectSetDouble0trendFastH1OBJPROPPRICE0emaFastH1[startH1;
ObjectSetInteger0trendFastH1OBJPROPTIME1timeH1[endH1;
ObjectSetDouble0trendFastH1OBJPROPPRICE1emaFastH1[endH1;

ObjectSetInteger0trendFastH1OBJPROPCOLORclrBlue;
ObjectSetInteger0trendFastH1OBJPROPSTYLESTYLESOLID;
ObjectSetInteger0trendFastH1OBJPROPWIDTH3;
ObjectSetInteger0trendFastH1OBJPROPRAYRIGHTtrue;
ObjectSetInteger0trendFastH1OBJPROPRAYLEFTfalse;
ObjectSetInteger0trendFastH1OBJPROPSELECTABLEfalse;
ObjectSetString0trendFastH1OBJPROPTEXTEMAFastH1;


DessinertrendlineEMASlowH1
ifstartH1>=0endH1>=0startH1<2000endH1<2000startH1=endH1

stringtrendSlowH1=TrendEMASlowH1Symbol;
ifObjectFind0trendSlowH1<0
ObjectCreate0trendSlowH1OBJTREND0timeH1[startH1emaSlowH1[startH1timeH1[endH1emaSlowH1[endH1;
else

ObjectSetInteger0trendSlowH1OBJPROPTIME0timeH1[startH1;
ObjectSetDouble0trendSlowH1OBJPROPPRICE0emaSlowH1[startH1;
ObjectSetInteger0trendSlowH1OBJPROPTIME1timeH1[endH1;
ObjectSetDouble0trendSlowH1OBJPROPPRICE1emaSlowH1[endH1;

ObjectSetInteger0trendSlowH1OBJPROPCOLORclrCrimson;
ObjectSetInteger0trendSlowH1OBJPROPSTYLESTYLESOLID;
ObjectSetInteger0trendSlowH1OBJPROPWIDTH3;
ObjectSetInteger0trendSlowH1OBJPROPRAYRIGHTtrue;
ObjectSetInteger0trendSlowH1OBJPROPRAYLEFTfalse;
ObjectSetInteger0trendSlowH1OBJPROPSELECTABLEfalse;
ObjectSetString0trendSlowH1OBJPROPTEXTEMASlowH1;




DessinerlesEMA50100200pourtendanceslonguescourbes

voidDrawLongTrendEMA

ifShowLongTrendEMA

Supprimerlessegmentssidsactiv
DeleteEMAObjectsEMA50;
DeleteEMAObjectsEMA100;
DeleteEMAObjectsEMA200;
return;


RcuprerlesvaleursEMA
doubleema50[ema100[ema200[;
datetimetime[;
ArraySetAsSeriesema50true;
ArraySetAsSeriesema100true;
ArraySetAsSeriesema200true;
ArraySetAsSeriestimetrue;

OPTIMISATION:Limiter1000bougiespasses1000futures
intcount=1000;1000bougiespasses
ifCopyBufferema50Handle00countema50<=0
CopyBufferema100Handle00countema100<=0
CopyBufferema200Handle00countema200<=0

ifDebugMode
PrintErreurrcuprationEMAlonguestendances;
return;


Rcuprerlestimestampspassesfutures
datetimetimePast[timeFuture[;
ArraySetAsSeriestimePasttrue;
ArraySetAsSeriestimeFuturetrue;

1000bougiespasses
ifCopyTimeSymbolPERIODM101000timePast<=0

ifDebugMode
PrintErreurrcuprationtimestampspassspourEMAlongues;
return;


Crer1000timestampsfutursprojection
datetimelastTime=timePast[999;
ArrayResizetimeFuture1000;
forinti=0;i<1000;i

timeFuture[i=lastTimei1PeriodSecondsPERIODM1;


Combinerlesdeuxarrays
ArrayResizetime2000;
forinti=0;i<1000;i
time[i=timePast[i;
forinti=0;i<1000;i
time[1000i=timeFuture[i;

OPTIMISATIONMAXIMALE:Nesupprimeretrecrerquesincessairevrifiertimestamp
staticdatetimelastEMAUpdate=0;
boolneedUpdate=TimeCurrentlastEMAUpdate>300;Misejourmaxtoutesles5minutesaulieude2

ifneedUpdate

Supprimerlesancienssegmentsseulementsincessaire
DeleteEMAObjectsEMA50;
DeleteEMAObjectsEMA100;
DeleteEMAObjectsEMA200;

OPTIMISATIONMAXIMALE:Crerdescourbesavec1000bougiespasses1000futures
tendrelesarraysEMApourinclurelesprojectionsfutures
ArrayResizeema502000;
ArrayResizeema1002000;
ArrayResizeema2002000;

ProjeterlesEMAdanslefuturextrapolationsimple
doubleema50Slope=ema50[999ema50[9001000;Pentesur100derniresbougies
doubleema100Slope=ema100[999ema100[9001000;
doubleema200Slope=ema200[999ema200[9001000;

forinti=1000;i<2000;i

ema50[i=ema50[999i999ema50Slope;
ema100[i=ema100[999i999ema100Slope;
ema200[i=ema200[999i999ema200Slope;


DrawEMACurveOptimizedEMA50ema50time2000clrLime120;
DrawEMACurveOptimizedEMA100ema100time2000clrYellow120;
DrawEMACurveOptimizedEMA200ema200time2000clrOrange120;

lastEMAUpdate=TimeCurrent;




SupprimerlesobjetsEMAavecunprfixedonn

voidDeleteEMAObjectsstringprefix

inttotal=ObjectsTotal0;
forinti=total1;i>=0;i

stringname=ObjectName0i;
ifStringFindnameprefix==0
ObjectDelete0name;




DessinerunecourbeEMAoptimisemoinsdesegments

voidDrawEMACurveOptimizedstringprefixdoublevalues[datetimetimes[intcountcolorclrintwidthintstep

OPTIMISATIONMAXIMALE:Dessinerunsegmenttouslessteppoints
intsegmentsDrawn=0;
intmaxSegments=20;Limiter20segmentsmaxpourperformanceaulieude50

forinti=count1;i>=stepsegmentsDrawn<maxSegments;i=step

intprevIdx=istep;
ifprevIdx<0prevIdx=0;

ifvalues[i>0values[prevIdx>0times[i>0times[prevIdx>0

stringsegName=prefixSymbolIntegerToStringsegmentsDrawn;

ifObjectFind0segName<0
ObjectCreate0segNameOBJTREND0times[ivalues[itimes[prevIdxvalues[prevIdx;
else

ObjectSetInteger0segNameOBJPROPTIME0times[i;
ObjectSetDouble0segNameOBJPROPPRICE0values[i;
ObjectSetInteger0segNameOBJPROPTIME1times[prevIdx;
ObjectSetDouble0segNameOBJPROPPRICE1values[prevIdx;


ObjectSetInteger0segNameOBJPROPCOLORclr;
ObjectSetInteger0segNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0segNameOBJPROPWIDTHwidth;
ObjectSetInteger0segNameOBJPROPRAYRIGHTfalse;
ObjectSetInteger0segNameOBJPROPRAYLEFTfalse;
ObjectSetInteger0segNameOBJPROPSELECTABLEfalse;

segmentsDrawn;





DessinerlespatternsDerivsimplifi


DessinelespatternsDerivflcheclignotantedynamique

voidDrawDerivPatternsOnChart

ifDrawDerivPatterns

Supprimerlaflchesidsactiv
ObjectDelete0DERIVARROWSymbol;
return;


Supprimertouteslesanciennesflcheshistoriquesnettoyagelimitpourperformance
staticdatetimelastCleanupTime=0;
ifTimeCurrentlastCleanupTime>=30Nettoyageseulementtoutesles30secondes

stringprefix=Deriv;
inttotal=ObjectsTotal0;
forinti=total1;i>=0;i

stringname=ObjectName0i;
ifStringFindnameprefix==0StringFindnameDERIVARROWSymbol<0
ObjectDelete0name;

lastCleanupTime=TimeCurrent;


VrifiersionaunsignalIAvalide
ifglastAIAction==glastAIConfidence<AIMinConfidence

Supprimerlaflchesipasdesignal
ObjectDelete0DERIVARROWSymbol;
return;


Rcuprerladernirebougie
MqlRatesrates[;
ArraySetAsSeriesratestrue;
ifCopyRatesSymbolPERIODCURRENT01rates<=0
return;

doublearrowPrice=rates[0close;
datetimearrowTime=rates[0time;

CreroumettrejourlaflcheuniqueseraclignotanteviaUpdateDerivArrowBlink
stringarrowName=DERIVARROWSymbol;
ENUMOBJECTarrowType=glastAIAction==buy?OBJARROWUP:OBJARROWDOWN;

ifObjectFind0arrowName<0

ifObjectCreate0arrowNamearrowType0arrowTimearrowPrice
return;

else

Mettrejourlapositiondelaflchepoursuivreladernirebougie
ObjectSetInteger0arrowNameOBJPROPTIME0arrowTime;
ObjectSetDouble0arrowNameOBJPROPPRICE0arrowPrice;


Propritsdelaflche
colorarrowColor=glastAIAction==buy?clrLime:clrRed;
ObjectSetInteger0arrowNameOBJPROPCOLORarrowColor;
ObjectSetInteger0arrowNameOBJPROPWIDTH4;
ObjectSetInteger0arrowNameOBJPROPARROWCODEglastAIAction==buy?233:234;
ObjectSetInteger0arrowNameOBJPROPSELECTABLEfalse;
ObjectSetInteger0arrowNameOBJPROPTIMEFRAMESOBJALLPERIODS;



DessinerleszonesSMCOrderBlockICT

voidDrawSMCZonesOnChart

ifDrawSMCZones

SupprimerleszonesSMCsidsactiv
DeleteSMCZones;
return;


RcuprerlesdonnesdeprixrcentespouridentifierleszonesSMC
MqlRatesrates[;
ArraySetAsSeriesratestrue;
intbars=100;Analyserles100derniresbougies

ifCopyRatesSymbolPERIODM50barsrates<bars
return;

IdentifierlesOrderBlockszonesdeforteraction
OrderBlockBullish:Bougiehaussiresuiviedunefortehausse
OrderBlockBearish:Bougiebaissiresuiviedunefortebaisse

forinti=5;i<bars5;i

DtecterOrderBlockBullish
ifrates[iclose>rates[iopenrates[i1close<rates[i1open

Vrifiersileprixarebondiaprscettebougie
boolisOrderBlock=false;
forintj=i1;j>=MathMax0i10;j

ifrates[jclose>rates[ihigh

isOrderBlock=true;
break;



ifisOrderBlock

DessinerzoneOrderBlockBullish
stringobName=SMCOBBullSymbolIntegerToStringi;
datetimetime1=rates[itime;
datetimetime2=TimeCurrentPeriodSecondsPERIODM550;tendre50bougiesverslefutur

ifObjectFind0obName<0
ObjectCreate0obNameOBJRECTANGLE0time1rates[ilowtime2rates[ihigh;
else

ObjectSetInteger0obNameOBJPROPTIME0time1;
ObjectSetDouble0obNameOBJPROPPRICE0rates[ihigh;
ObjectSetInteger0obNameOBJPROPTIME1time2;
ObjectSetDouble0obNameOBJPROPPRICE1rates[ilow;


ObjectSetInteger0obNameOBJPROPCOLORclrLime;
ObjectSetInteger0obNameOBJPROPBACK1;
ObjectSetInteger0obNameOBJPROPFILL1;
ObjectSetInteger0obNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0obNameOBJPROPWIDTH1;
ObjectSetInteger0obNameOBJPROPSELECTABLEfalse;
ObjectSetString0obNameOBJPROPTEXTOBBull;



DtecterOrderBlockBearish
ifrates[iclose<rates[iopenrates[i1close>rates[i1open

Vrifiersileprixachutaprscettebougie
boolisOrderBlock=false;
forintj=i1;j>=MathMax0i10;j

ifrates[jclose<rates[ilow

isOrderBlock=true;
break;



ifisOrderBlock

DessinerzoneOrderBlockBearish
stringobName=SMCOBBearSymbolIntegerToStringi;
datetimetime1=rates[itime;
datetimetime2=TimeCurrentPeriodSecondsPERIODM550;

ifObjectFind0obName<0
ObjectCreate0obNameOBJRECTANGLE0time1rates[ihightime2rates[ilow;
else

ObjectSetInteger0obNameOBJPROPTIME0time1;
ObjectSetDouble0obNameOBJPROPPRICE0rates[ilow;
ObjectSetInteger0obNameOBJPROPTIME1time2;
ObjectSetDouble0obNameOBJPROPPRICE1rates[ihigh;


ObjectSetInteger0obNameOBJPROPCOLORclrRed;
ObjectSetInteger0obNameOBJPROPBACK1;
ObjectSetInteger0obNameOBJPROPFILL1;
ObjectSetInteger0obNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0obNameOBJPROPWIDTH1;
ObjectSetInteger0obNameOBJPROPSELECTABLEfalse;
ObjectSetString0obNameOBJPROPTEXTOBBear;






SupprimerleszonesSMC

voidDeleteSMCZones

inttotal=ObjectsTotal0;
forinti=total1;i>=0;i

stringname=ObjectName0i;
ifStringFindnameSMCOB==0
ObjectDelete0name;




MetjourleclignotementdelaflcheDeriv

voidUpdateDerivArrowBlink

ifDrawDerivPatterns

Supprimerlaflchesidsactiv
ObjectDelete0DERIVARROWSymbol;
return;


stringarrowName=DERIVARROWSymbol;
ifObjectFind0arrowName<0
return;

VrifiersionaunsignalIAvalide
ifglastAIAction==glastAIConfidence<AIMinConfidence

ObjectDelete0arrowName;
return;


OPTIMISATION:Faireclignoterlaflchemoinsfrquemmenttoutesles2secondes
staticdatetimelastBlinkTime=0;
staticboolblinkState=false;

ifTimeCurrentlastBlinkTime>=2Clignotementtoutesles2secondespourperformance

blinkState=blinkState;
lastBlinkTime=TimeCurrent;

Togglevisibilitypourcrerleffetdeclignotement
ObjectSetInteger0arrowNameOBJPROPHIDDENblinkState?true:false;

Mettrejourlapositionpoursuivreladernirebougie
MqlRatesrates[;
ArraySetAsSeriesratestrue;
ifCopyRatesSymbolPERIODCURRENT01rates>0

ObjectSetInteger0arrowNameOBJPROPTIME0rates[0time;
ObjectSetDouble0arrowNameOBJPROPPRICE0rates[0close;
ChartRedraw0;Redrawseulementsionamisjourlaposition





DessinerlesprdictionsIAsurlegraphique200bougiesfutures

voidDrawPredictionsOnChartstringpredictionData

DEBUG:Afficherlesdonnesreues
ifDebugMode
PrintDEBUGDrawPredictionsOnChartappelavec:predictionData;

Sipasdedonnessortir
ifpredictionData==

ifDebugMode
PrintDEBUGAucunedonnedeprdictiondessiner;
return;


NettoyerlesanciennesprdictionsETautresobjetsquipourraientgner
inttotal=ObjectsTotal0;
forinti=total1;i>=0;i

stringname=ObjectName0i;
Nettoyertouslesobjetsdeprdiction
ifStringFindnamePREDICTION==0
StringFindnameFUTURECANDLES==0
StringFindnameCORRECTION==0
StringFindnameAIZONE==0
StringFindnameAIARROW==0

ObjectDelete0name;



ParserlesdonnesdeprdictionformatJSONrelreu
Formatreu:prediction:direction:DOWNconfidence:099pricetarget:100394

Extraireladirectiondelaprdiction
stringdirection=;
doubleconfidence=00;

Chercherdaborddanspredictiondirectionformatcorrect
intpredDirPos=StringFindpredictionData\direction\;
ifpredDirPos>=0

intdirPos=StringFindpredictionData\direction\predDirPos;
ifdirPos>=0

intcolonPos=StringFindpredictionData:dirPos;
ifcolonPos>=0

intstart=colonPos1;
Sauterlesguillemets
whilestart<StringLenpredictionDataStringSubstrpredictionDatastart1==
start;
ifstart<StringLenpredictionDataStringSubstrpredictionDatastart1==\
start;

intend=StringFindpredictionData\start;
ifend>start

direction=StringSubstrpredictionDatastartendstart;
ifDebugMode
PrintDEBUGDirectionextraite:direction;




Extrairelaconfiance
intconfPos=StringFindpredictionData\confidence\predDirPos;
ifconfPos>=0

intcolonPos=StringFindpredictionData:confPos;
ifcolonPos>=0

intstart=colonPos1;
intend=StringFindpredictionDatastart;
ifend<0end=StringFindpredictionDatastart;
ifend>start

stringconfStr=StringSubstrpredictionDatastartendstart;
confidence=StringToDoubleconfStr;
ifDebugMode
PrintDEBUGConfianceextraite:DoubleToStringconfidence2;





DEBUG:Sipasdedirectionvalidecreruneprdictiondetest
ifdirection==

ifDebugMode
PrintDEBUGPasdedirectiontrouvecrationdeprdictiondetest;

Creruneprdictiondetestpourvrifierledessin
direction=buy;
confidence=075;

else

ConvertirUPDOWNenbuysell
ifdirection==UP
direction=buy;
elseifdirection==DOWN
direction=sell;

ifDebugMode
PrintDEBUGDirectionconvertie:direction;


Sipasdedirectionclairesortir
ifdirection==
return;

Rcuprerleprixactuel
doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

Dessinerles1000bougiesfuturesprditestrajectoireraliste
datetimefutureTime[;
doublefuturePrices[;
doublechannelHigh[;
doublechannelLow[;

ArrayResizefutureTime1000;
ArrayResizefuturePrices1000;
ArrayResizechannelHigh1000;
ArrayResizechannelLow1000;

datetimecurrentTime=TimeCurrent;

Paramtrespourtrajectoireraliste
doubleatr[;
ArraySetAsSeriesatrtrue;
doublecurrentVolatility=0001;Volatilitactuelle
ifCopyBufferatrHandle001atr>0atr[0>0
currentVolatility=atr[0currentPrice;

Gnrerlesprixprditsavectrajectoirecourbeexponentielleamortie
forinti=0;i<1000;i

futureTime[i=currentTimei1PeriodSecondsPERIODM1;

Trajectoireexponentielleavecacclrationdclrationprogressive
doubleprogress=doublei10000;Progression0010

Facteurdacclrationcommencelentacclrepuisamortit
doubleaccelerationFactor=10MathPow10progress20;CourbeenS

Mouvementdebasebassurladirectionetlaconfiance
doublebaseMove=currentPricecurrentVolatilityconfidence100;10xATRpour1000bougies

Appliquerlacclrationprogressive
doublepriceMove=baseMoveaccelerationFactor;

Ajouterdescyclesdemarchvaguesplusraliste
doublemarketCycle=MathSinprogress31415926535940currentVolatilitycurrentPrice03;

Ajouterdubruitalatoireproportionnellavolatilit
doublenoise=MathRand2001001000currentVolatilitycurrentPrice01;

ifStringComparedirectionbuy==0

futurePrices[i=currentPricepriceMovemarketCyclenoise;

elsesell

futurePrices[i=currentPricepriceMovemarketCyclenoise;


Canaldynamiquequislargitavecletempsincertitudecroissante
doubleuncertaintyFactor=10progress20;Canalslargitde1x3x
doublechannelWidth=currentVolatilitycurrentPrice05uncertaintyFactor;

channelHigh[i=futurePrices[ichannelWidth;
channelLow[i=futurePrices[ichannelWidth;


Dessinerlalignedeprdictionprincipalecourbesur1000points
stringpredictionLineName=PREDICTIONLINESymbol;
ifObjectCreate0predictionLineNameOBJTREND0futureTime[0futurePrices[0futureTime[999futurePrices[999

ObjectSetInteger0predictionLineNameOBJPROPCOLORStringComparedirectionbuy==0?clrDodgerBlue:clrOrangeRed;
ObjectSetInteger0predictionLineNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0predictionLineNameOBJPROPWIDTH3;
ObjectSetInteger0predictionLineNameOBJPROPBACKfalse;
ObjectSetString0predictionLineNameOBJPROPTEXTPredictiondirection==buy?BUY:SELLDoubleToStringconfidence1001;


Dessinerlescanauxdeprdiction
stringchannelHighName=PREDICTIONCHANNELHIGHSymbol;
stringchannelLowName=PREDICTIONCHANNELLOWSymbol;

Canalsuprieurcourbesur1000points
ifObjectCreate0channelHighNameOBJTREND0futureTime[0channelHigh[0futureTime[999channelHigh[999

ObjectSetInteger0channelHighNameOBJPROPCOLORStringComparedirectionbuy==0?clrLightBlue:clrLightPink;
ObjectSetInteger0channelHighNameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0channelHighNameOBJPROPWIDTH1;
ObjectSetInteger0channelHighNameOBJPROPBACK1;


Canalinfrieurcourbesur1000points
ifObjectCreate0channelLowNameOBJTREND0futureTime[0channelLow[0futureTime[999channelLow[999

ObjectSetInteger0channelLowNameOBJPROPCOLORStringComparedirectionbuy==0?clrLightBlue:clrLightPink;
ObjectSetInteger0channelLowNameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0channelLowNameOBJPROPWIDTH1;
ObjectSetInteger0channelLowNameOBJPROPBACK1;


Ajouterdeslabelspourlespointscls
stringlabelName=PREDICTIONLABELSymbol;
ifObjectCreate0labelNameOBJTEXT0futureTime[50futurePrices[50

stringlabelText=direction==buy?BUY:SELLPrediction\nConf:DoubleToStringconfidence1001\nTarget:DoubleToStringfuturePrices[50Digits;
ObjectSetString0labelNameOBJPROPTEXTlabelText;
ObjectSetInteger0labelNameOBJPROPCOLORStringComparedirectionbuy==0?clrDodgerBlue:clrOrangeRed;
ObjectSetInteger0labelNameOBJPROPFONTSIZE8;
ObjectSetInteger0labelNameOBJPROPBACKfalse;
ObjectSetInteger0labelNameOBJPROPANCHORANCHORLEFT;


ifDebugMode
PrintPrdictiondessine:directionconf:DoubleToStringconfidence1001;



Dessinerlesbougiesfuturesadaptesautimeframe
CredesbougiesvisiblespourM1M5H1avectailles
etcouleursdiffrentesselonletimeframeactuel

voidDrawFutureCandlesAdaptive

Rcuprerletimeframeactuel
ENUMTIMEFRAMEScurrentTF=ENUMTIMEFRAMESPeriod;

Paramtresadaptatifsselonletimeframe
intcandleCount=0;Nombredebougiesdessiner
colorcandleColor=clrWhite;
intcandleWidth=1;
doublebodyTransparency=07;

Adapterselonletimeframe
switchcurrentTF

casePERIODM1:
candleCount=20;20bougiesfuturespourM1
candleColor=clrYellow;JaunepourM1
candleWidth=1;
bodyTransparency=08;
break;

casePERIODM5:
candleCount=12;12bougiesfuturespourM5
candleColor=clrCyan;CyanpourM5
candleWidth=2;
bodyTransparency=06;
break;

casePERIODH1:
candleCount=8;8bougiesfuturespourH1
candleColor=clrMagenta;MagentapourH1
candleWidth=3;
bodyTransparency=04;
break;

default:
candleCount=10;Dfaut
candleColor=clrWhite;
candleWidth=2;
bodyTransparency=05;
break;


Rcuprerlesdonnesdeprdiction
ifglastPredictionData==
return;

stringdirection=;
doubleconfidence=00;

Extraireladirectionetlaconfiance
intpredDirPos=StringFindglastPredictionData\direction\;
ifpredDirPos>=0

intdirPos=StringFindglastPredictionData\direction\predDirPos;
ifdirPos>=0

intcolonPos=StringFindglastPredictionData:dirPos;
ifcolonPos>=0

intstart=colonPos1;
Sauterlesguillemets
whilestart<StringLenglastPredictionDataStringSubstrglastPredictionDatastart1==
start;
ifstart<StringLenglastPredictionDataStringSubstrglastPredictionDatastart1==\
start;

intend=StringFindglastPredictionData\start;
ifend>start

direction=StringSubstrglastPredictionDatastartendstart;




Extrairelaconfiance
intconfPos=StringFindglastPredictionData\confidence\predDirPos;
ifconfPos>=0

intcolonPos=StringFindglastPredictionData:confPos;
ifcolonPos>=0

intstart=colonPos1;
whilestart<StringLenglastPredictionDataStringSubstrglastPredictionDatastart1==
start;
ifstart<StringLenglastPredictionDataStringSubstrglastPredictionDatastart1==\
start;

intend=StringFindglastPredictionData\start;
ifend>start

stringconfStr=StringSubstrglastPredictionDatastartendstart;
confidence=StringToDoubleconfStr;





Sipasdedirectionclairesortir
ifdirection==
return;

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doubleaskPrice=SymbolInfoDoubleSymbolSYMBOLASK;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

RcuprerlATRactuelpourdesbougiesralistes
doubleatrCurrent[;
ArraySetAsSeriesatrCurrenttrue;
doubleatrValue=0;

ifCopyBufferatrHandle001atrCurrent>0
atrValue=atrCurrent[0;
else
atrValue=point20;ValeurpardfautsiATRnondisponible

Nettoyerlesanciennesbougiesfuturesetlgendes
stringprefix=FUTURECANDLESymbol;
stringlegendPrefix=FUTURECANDLESLEGENDSymbol;
ObjectsDeleteAll0prefix;
ObjectsDeleteAll0legendPrefix;

Paramtresdevolatilitselonletimeframe
doublevolatilityMultiplier=10;
intbodySizeMultiplier=1;

switchcurrentTF

casePERIODM1:
volatilityMultiplier=08;MoinsdevolatilitsurM1
bodySizeMultiplier=1;
break;
casePERIODM5:
volatilityMultiplier=10;VolatilitnormalesurM5
bodySizeMultiplier=2;
break;
casePERIODH1:
volatilityMultiplier=15;PlusdevolatilitsurH1
bodySizeMultiplier=3;
break;
default:
volatilityMultiplier=10;
bodySizeMultiplier=2;
break;


Dessinerlesbougiesfuturesensuivantlalignedeprdictionetlecanal
datetimecurrentTime=TimeCurrent;
doublelastClosePrice=currentPrice;

PROFILHISTORIQUEoptionnel:calibrerratioscorpsmchessurlhistoriquercentduTFcourant
Objectif:rendrelatexturedesbougiesfuturessimilaireausymboleFINXVolatilityetc
doubleavgBodyRatio=055;corpsrange
doubleavgUpperWickRatio=022;mchesuprange
doubleavgLowerWickRatio=023;mcheinfrange
doubleavgRange=atrValue;fallbackATR

ifUseHistoricalCandleProfile

intlookback=CandleProfileLookback;
iflookback<30lookback=30;
iflookback>500lookback=500;

MqlRateshist[;
ArraySetAsSerieshisttrue;
intcopied=CopyRatesSymbolcurrentTF1lookbackhist;bougiescltures
ifcopied>30

doublesumBody=0sumUpper=0sumLower=0sumRange=0;
intcnt=0;
forinti=0;i<copied;i

doubleh=hist[ihigh;
doublel=hist[ilow;
doubleo=hist[iopen;
doublec=hist[iclose;
doublerange=hl;
ifrange<=0continue;
doublebody=MathAbsco;
doubleupper=hMathMaxoc;
doublelower=MathMinocl;
ifupper<0upper=0;
iflower<0lower=0;

sumBody=bodyrange;
sumUpper=upperrange;
sumLower=lowerrange;
sumRange=range;
cnt;


ifcnt>20

avgBodyRatio=sumBodycnt;
avgUpperWickRatio=sumUppercnt;
avgLowerWickRatio=sumLowercnt;
avgRange=sumRangecnt;

Bornesraisonnablespourviterlesprofilsaberrants
avgBodyRatio=MathMax010MathMin090avgBodyRatio;
avgUpperWickRatio=MathMax002MathMin070avgUpperWickRatio;
avgLowerWickRatio=MathMax002MathMin070avgLowerWickRatio;
ifavgRange<=0avgRange=atrValue;




Rcuprerlesdonnesdeprdictionexistanteslignesetcanaux
doublepredictionPrices[;
doublechannelHighs[;
doublechannelLows[;
datetimepredictionTimes[;

ArrayResizepredictionPricescandleCount;
ArrayResizechannelHighscandleCount;
ArrayResizechannelLowscandleCount;
ArrayResizepredictionTimescandleCount;

Calculerlespointsdeprdictionpourchaquebougiefuture
forinti=0;i<candleCount;i

Tempsdelabougiefuture
predictionTimes[i=currentTimei1PeriodSecondscurrentTF;

Progressiondansletemps01
doubleprogress=doubleidoublecandleCount;

Driftcontrl:bassurATRetconfiancebornparPredictionMaxDriftATR
doublemaxDrift=PredictionMaxDriftATRatrValuevolatilityMultiplier;
doubledrift=maxDriftconfidenceprogress;
doublebaseMove=0;
ifStringComparedirectionbuy==0baseMove=drift;
elseifStringComparedirectionsell==0baseMove=drift;

Cyclesdemarch:amplitudeproportionnelleaurangemoyen
doublemarketCycle=MathSinprogress31415926535930avgRange035;

Prixdeprdictioncentral
predictionPrices[i=currentPricebaseMovemarketCycle;

Canal:bassurrangemoyenplusstableque100ATRbrutincertitudecroissante
doubleuncertaintyFactor=10progress13;
doublechannelWidth=MathMaxatrValue06avgRange09uncertaintyFactor;

channelHighs[i=predictionPrices[ichannelWidth;
channelLows[i=predictionPrices[ichannelWidth;


Dessinerlesbougiesfuturesensuivantexactementlalignedeprdiction
forinti=0;i<candleCount;i

datetimecandleTime=predictionTimes[i;

Labougiedoitsuivrelalignedeprdictioncentrale
doubletargetPrice=predictionPrices[i;

Variationcontrle:moinsderandomtexturecalquesurprofilhistorique
doublemaxVariation=channelHighs[ichannelLows[i018;rduit18ducanal
doublerandomVariation=MathRand2001001000maxVariation;

CalculerOHLC:open=dernierclosecloseprochedetargetpuismchescorpsselonratiosmoyens
doubleopenPrice=lastClosePrice;
doubleclosePrice=targetPricerandomVariation;

Sassurerquelabougierestedanslecanal
closePrice=MathMaxchannelLows[iMathMinchannelHighs[iclosePrice;
openPrice=MathMaxchannelLows[iMathMinchannelHighs[iopenPrice;

Dclarerlesvariablespourlesmches
doubleupperWick=0;
doublelowerWick=0;

ADAPTATIONSPCIALEPOURBOOMCRASH
boolisBoomSymbol=StringFindSymbolBoom=1;
boolisCrashSymbol=StringFindSymbolCrash=1;
boolisBoomCrashSymbol=isBoomSymbolisCrashSymbol;

VariablespourBoomCrashdclaresicipourtreaccessiblespartout
boolisSpike=false;
doublespikeMultiplier=10;

ifisBoomCrashSymbol

PourBoomCrash:70destickspetitesbougies30despikesgrandesbougies
isSpike=MathRand100<30;30dechancedespike

ifisSpike

SPIKE:Bougietrslonguedansladirectiondelatendance
spikeMultiplier=30MathRand2001000;3x5xlataillenormale

ifStringComparedirectionbuy==0

SpikehaussierpourBUY
closePrice=openPriceatrValuespikeMultiplier08;
Mchesasymtriquespourspike
upperWick=closePriceMathRand2051000atrValue02;
lowerWick=openPriceMathRand1051000atrValue01;

elseifStringComparedirectionsell==0

SpikebaissierpourSELL
closePrice=openPriceatrValuespikeMultiplier08;
Mchesasymtriquespourspike
upperWick=openPriceMathRand1051000atrValue01;
lowerWick=closePriceMathRand2051000atrValue02;


Forcerleprixdanslecanal
closePrice=MathMaxchannelLows[iMathMinchannelHighs[iclosePrice;
upperWick=MathMaxchannelLows[iMathMinchannelHighs[iupperWick;
lowerWick=MathMaxchannelLows[iMathMinchannelHighs[ilowerWick;

else

STICK:Bougietrspetiteconsolidation
doublestickSize=atrValue01;10delATRseulement
doublestickDirection=MathRand2001001000stickSize;

closePrice=openPricestickDirection;

Mchestrscourtespoursticks
upperWick=MathMaxopenPriceclosePriceMathRand511000atrValue005;
lowerWick=MathMinopenPriceclosePriceMathRand511000atrValue005;

Forcerdanslecanal
closePrice=MathMaxchannelLows[iMathMinchannelHighs[iclosePrice;
upperWick=MathMaxchannelLows[iMathMinchannelHighs[iupperWick;
lowerWick=MathMaxchannelLows[iMathMinchannelHighs[ilowerWick;


else

Pourlesautressymboles:comportementplushistorique
Dterminerunrangecibleprochedurangemoyen
doublebaseRange=avgRange075MathRand501000;075x125x
baseRange=MathMaxpoint10baseRange;

Corpsselonratiomoyenavecpetitevariation
doublebodyRatio=avgBodyRatioMathRand20101000010;010010=001
bodyRatio=MathMax010MathMin085bodyRatio;
doublebodySize=baseRangebodyRatio;

Orientation:majoritairementdanslesensdirectionmaispastoujours
boolbullish=closePrice>=openPrice;
ifStringComparedirectionbuy==0
bullish=MathRand100<70;
elseifStringComparedirectionsell==0
bullish=MathRand100<30;

ReconstituercloseautourdeopenavecbodySize
ifbullish
closePrice=openPricebodySize;
else
closePrice=openPricebodySize;

Reforcerdanslecanal
closePrice=MathMaxchannelLows[iMathMinchannelHighs[iclosePrice;

Mchesselonratiosmoyens
doubleupperRatio=avgUpperWickRatioMathRand20101000008;
doublelowerRatio=avgLowerWickRatioMathRand20101000008;
upperRatio=MathMax002MathMin070upperRatio;
lowerRatio=MathMax002MathMin070lowerRatio;

doubletop=MathMaxopenPriceclosePrice;
doublebot=MathMinopenPriceclosePrice;
upperWick=topbaseRangeupperRatio;
lowerWick=botbaseRangelowerRatio;

Sassurerquelesmchesrestentdanslecanal
upperWick=MathMaxchannelLows[iMathMinchannelHighs[iupperWick;
lowerWick=MathMaxchannelLows[iMathMinchannelHighs[ilowerWick;


Dterminerlacouleurdelabougieselonladirectionetletype
colorbodyColor=clrWhite;
colorwickColor=candleColor;

ifclosePrice>openPrice

Bougiehaussireverte
bodyColor=clrGreen;
wickColor=clrGreen;

elseifclosePrice<openPrice

Bougiebaissirerouge
bodyColor=clrRed;
wickColor=clrRed;

else

Dojiprixdouverture=prixdefermeture
bodyColor=candleColor;
wickColor=candleColor;


Nomsdesobjetspourcettebougie
stringcandleName=prefixIntegerToStringi;
stringwickName=candleNameWICK;
stringbodyName=candleNameBODY;
stringshadowName=candleNameSHADOW;

Dessinerlombrecompltedehautenbasplusfinequelamche
ifObjectCreate0shadowNameOBJTREND0candleTimeupperWickcandleTimelowerWick

ObjectSetInteger0shadowNameOBJPROPCOLORclrGray;
ObjectSetInteger0shadowNameOBJPROPSTYLESTYLEDOT;
ObjectSetInteger0shadowNameOBJPROPWIDTH1;
ObjectSetInteger0shadowNameOBJPROPBACK1;
ObjectSetInteger0shadowNameOBJPROPRAYRIGHTfalse;


Dessinerlamcheprincipalepluspaisseetcolore
ifObjectCreate0wickNameOBJTREND0candleTimeupperWickcandleTimelowerWick

ObjectSetInteger0wickNameOBJPROPCOLORwickColor;
ObjectSetInteger0wickNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0wickNameOBJPROPWIDTHMathMax1candleWidth;
ObjectSetInteger0wickNameOBJPROPBACK0;Aupremierplan
ObjectSetInteger0wickNameOBJPROPRAYRIGHTfalse;


Dessinerlecorpsdelabougierectangleentreopenetclose
doublebodyTop=MathMaxopenPriceclosePrice;
doublebodyBottom=MathMinopenPriceclosePrice;

Ajusterlalargeurducorpsselonletimeframe
doublebodyWidth=PeriodSecondscurrentTF06;60delalargeurdelabougie

Pourlesdojisopen=closecrerunpetitcorpsvisible
ifMathAbsbodyTopbodyBottom<point2

doublecenterPrice=bodyTopbodyBottom2;
bodyTop=centerPricepoint;
bodyBottom=centerPricepoint;


ifObjectCreate0bodyNameOBJRECTANGLE0
datetimecandleTimebodyWidth2bodyBottom
datetimecandleTimebodyWidth2bodyTop

ObjectSetInteger0bodyNameOBJPROPCOLORbodyColor;
ObjectSetInteger0bodyNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0bodyNameOBJPROPWIDTH1;Bordurefine
ObjectSetInteger0bodyNameOBJPROPBACKfalse;Aupremierplan
ObjectSetInteger0bodyNameOBJPROPFILL1;Rempli

Transparenceselonlaconfianceetladirection
inttransparency=int25510confidence07;Plusdetransparencesimoinsdeconfiance

Ajusterlatransparenceselonletypedebougie
ifclosePrice>openPrice

Bougieshaussiresplusvisibles
transparency=inttransparency08;

elseifclosePrice<openPrice

Bougiesbaissiresmodrmentvisibles
transparency=inttransparency09;



Mettrejourpourlaprochainebougie
lastClosePrice=closePrice;

DebugpourBoomCrash:afficherletypedebougiegnre
ifDebugModeisBoomCrashSymbol

stringcandleType=;
ifisSpike
candleType=SPIKEDoubleToStringspikeMultiplier1x;
else
candleType=STICK;

PrintBougieBoomCrashgnre:candleTypeDirection:closePrice>openPrice?UP:DOWN
Open:DoubleToStringopenPriceDigits
Close:DoubleToStringclosePriceDigits
Range:DoubleToStringMathAbsclosePriceopenPricepoint1pips;



DESSINERLESLIGNESDEPRDICTIONETCANAUXCOURBES
Lignedeprdictionprincipalecourbe
stringpredictionLineName=FUTURECANDLESPREDICTIONLINESymbol;
ifObjectCreate0predictionLineNameOBJTREND0predictionTimes[0predictionPrices[0predictionTimes[candleCount1predictionPrices[candleCount1

ObjectSetInteger0predictionLineNameOBJPROPCOLORStringComparedirectionbuy==0?clrDodgerBlue:clrOrangeRed;
ObjectSetInteger0predictionLineNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0predictionLineNameOBJPROPWIDTH3;
ObjectSetInteger0predictionLineNameOBJPROPBACKfalse;
ObjectSetString0predictionLineNameOBJPROPTEXTPredictiondirection==buy?BUY:SELLDoubleToStringconfidence1001;


Canalsuprieurcourbe
stringchannelHighName=FUTURECANDLESCHANNELHIGHSymbol;
ifObjectCreate0channelHighNameOBJTREND0predictionTimes[0channelHighs[0predictionTimes[candleCount1channelHighs[candleCount1

ObjectSetInteger0channelHighNameOBJPROPCOLORStringComparedirectionbuy==0?clrLightBlue:clrLightPink;
ObjectSetInteger0channelHighNameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0channelHighNameOBJPROPWIDTH1;
ObjectSetInteger0channelHighNameOBJPROPBACKtrue;


Canalinfrieurcourbe
stringchannelLowName=FUTURECANDLESCHANNELLOWSymbol;
ifObjectCreate0channelLowNameOBJTREND0predictionTimes[0channelLows[0predictionTimes[candleCount1channelLows[candleCount1

ObjectSetInteger0channelLowNameOBJPROPCOLORStringComparedirectionbuy==0?clrLightBlue:clrLightPink;
ObjectSetInteger0channelLowNameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0channelLowNameOBJPROPWIDTH1;
ObjectSetInteger0channelLowNameOBJPROPBACKtrue;


Ajouterunelgendedtaille
stringlegendName=FUTURECANDLESLEGENDSymbol;
doublelegendPrice=currentPriceatrValue25;
datetimelegendTime=currentTimePeriodSecondscurrentTF2;

ifObjectCreate0legendNameOBJTEXT0legendTimelegendPrice

stringvolatilityText=;
ifvolatilityMultiplier<10
volatilityText=Faiblevolatilit;
elseifvolatilityMultiplier>10
volatilityText=Fortevolatilit;
else
volatilityText=Volatilitnormale;

stringlegendText=PRDICTIONStringSubstrEnumToStringcurrentTF7
\nDirection:direction==buy?BUY:SELL
\nConfiance:DoubleToStringconfidence1001
\nATR:DoubleToStringatrValuepoint1pips
volatilityText;

AjouterdesinformationsspcifiquespourBoomCrash
boolisBoomCrashSymbol=StringFindSymbolBoom=1StringFindSymbolCrash=1;
ifisBoomCrashSymbol

legendText=\n\nBOOMCRASHMODE:;
legendText=\n70Stickspetitesbougies;
legendText=\n30Spikesgrandesimpulsions;
legendText=\nBassurdonneshistoriques;


ObjectSetString0legendNameOBJPROPTEXTlegendText;
ObjectSetInteger0legendNameOBJPROPCOLORcandleColor;
ObjectSetInteger0legendNameOBJPROPFONTSIZE9;
ObjectSetString0legendNameOBJPROPFONTArialBold;
ObjectSetInteger0legendNameOBJPROPBACKfalse;
ObjectSetInteger0legendNameOBJPROPANCHORANCHORLEFTUPPER;


Ajouterunindicateurvisueldelazonedeprdiction
stringzoneName=FUTURECANDLESZONESymbol;
doublezoneTop=currentPriceatrValue3;
doublezoneBottom=currentPriceatrValue3;
datetimezoneStart=currentTimePeriodSecondscurrentTF;
datetimezoneEnd=currentTimecandleCount2PeriodSecondscurrentTF;

ifObjectCreate0zoneNameOBJRECTANGLE0zoneStartzoneBottomzoneEndzoneTop

ObjectSetInteger0zoneNameOBJPROPCOLORcandleColor;
ObjectSetInteger0zoneNameOBJPROPSTYLESTYLEDASH;
ObjectSetInteger0zoneNameOBJPROPWIDTH1;
ObjectSetInteger0zoneNameOBJPROPBACK1;
ObjectSetInteger0zoneNameOBJPROPFILL0;Nonrempli


ifDebugMode

PrintBOUGIESFUTURESCRES:;
PrintTimeframe:EnumToStringcurrentTF;
PrintNombredebougies:candleCount;
PrintDirection:StringToUpperdirection;
PrintConfiance:DoubleToStringconfidence1001;
PrintATRactuel:DoubleToStringatrValuepoint1pips;
PrintVolatilit:volatilityMultiplier<10?Faible:volatilityMultiplier>10?Forte:Normale;
PrintPrixactuel:DoubleToStringcurrentPriceDigits;
PrintMultiplicateurvolatilit:DoubleToStringvolatilityMultiplier2;
PrintCouleurdesbougies:StringComparedirectionbuy==0?Verteshaussires:Rougesbaissires;


NOUVEAU:TraderautomatiquementbassurlesbougiesfuturessiIAnestpasenattente
ifStringComparedirectionhold=0confidence>=070gaiFallbackMode

TradeBasedOnFutureCandlesdirectionconfidencecurrentPriceatrValue;




Traderautomatiquementbassurlesbougiesfutures
Excutedesordresquandlaconfianceestleveetdirectionclaire

voidTradeBasedOnFutureCandlesstringdirectiondoubleconfidencedoublecurrentPricedoubleatrValue

Vrifiersionpeuttraderpasdepositionactivesurcesymbole
ifPositionsTotal>0

Vrifiersilyadjunepositionsurcesymbole
forinti=0;i<PositionsTotal;i

ifPositionGetSymboli==Symbol

ifDebugMode
PrintPositiondjexistantesurSymbolpasdenouvellepositionbasesurbougiesfutures;
return;




doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
ENUMORDERTYPEorderType=WRONGVALUE;

Dterminerletypedordreselonladirection
ifStringComparedirectionbuy==0

orderType=ORDERTYPEBUY;

elseifStringComparedirectionsell==0

orderType=ORDERTYPESELL;

else

ifDebugMode
PrintDirectionnonreconnuepourtradingbassurbougiesfutures:direction;
return;


RGLEBOOMCRASH:pasdeBUYsurCrashpasdeSELLsurBoom
ifStringFindSymbolCrash>=0orderType==ORDERTYPEBUYreturn;
ifStringFindSymbolBoom>=0orderType==ORDERTYPESELLreturn;

CalculerSLTPbasssurlATRetladirectiondesbougiesfutures
doublestopLoss=0;
doubletakeProfit=0;

iforderType==ORDERTYPEBUY

PourBUY:SLsousleprixactuelTPaudessus
stopLoss=currentPriceatrValue15;
takeProfit=currentPriceatrValue30;1:2ratio

elseSELL

PourSELL:SLaudessusduprixactuelTPendessous
stopLoss=currentPriceatrValue15;
takeProfit=currentPriceatrValue30;1:2ratio


Validationdesdistancesminimales
doubleminDistance=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVELPoint;
doubleslDistance=MathAbscurrentPricestopLoss;
doubletpDistance=MathAbstakeProfitcurrentPrice;

GESTIONSPCIALESTEPINDEX
boolisStepIndex=StringFindSymbolStepIndex=1;
ifisStepIndex

minDistance=MathMaxminDistance20point;
ifDebugMode
PrintStepIndexDistanceminimalepourordrebasbougiesfutures:DoubleToStringminDistancepoint0points;


ifslDistance<minDistancetpDistance<minDistance

ifDebugMode
PrintDistancesSLTPtropfaiblespourordrebasbougiesfutures:SL=DoubleToStringslDistancepoint0TP=DoubleToStringtpDistancepoint0;
return;


Calculerlatailledepositionselonlaconfiance
doublelotSize=InitialLotSize;
ifconfidence>=090
lotSize=InitialLotSize15;Augmenterlataillesitrshauteconfiance
elseifconfidence<080
lotSize=InitialLotSize08;Rduiresiconfiancemodre

lotSize=NormalizeLotSizelotSize;

Placerlordreaumarchimmdiatement
stringorderComment=FutureCandlesAIdirection==buy?BUY:SELLconf:DoubleToStringconfidence1001;

iforderType==ORDERTYPEBUY

EnvoyernotificationAVANTlexcutiondelordre
ifDisableNotifications

stringnotificationText=BUYFutureCandlesAI\nSymbol@DoubleToStringcurrentPriceDigits\nConfiance:DoubleToStringconfidence1001\nPositionOUVERTEIMMDIATEMENT;
SendNotificationnotificationText;
AlertnotificationText;


Excuterlordreimmdiatementaprslanotification
iftradeBuylotSizeSymbolcurrentPricestopLosstakeProfitorderComment

doubleriskUSD=slDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=tpDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintORDREBUYBASBOUGIESFUTURESPOSITIONOUVERTE:;
PrintDirection:BUYconfiance:DoubleToStringconfidence1001;
PrintPrixdentre:DoubleToStringcurrentPriceDigits;
PrintStopLoss:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTakeProfit:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;
PrintTaille:DoubleToStringlotSize2;
PrintBassurprdictiondesbougiesfuturessurEnumToStringENUMTIMEFRAMESPeriod;
PrintPositionouverteIMMDIATEMENTaprsnotification;

Envoyernotificationdeconfirmation
ifDisableNotifications

stringconfirmText=BUYEXECUT\nSymbol@DoubleToStringcurrentPriceDigits\nSL:DoubleToStringstopLossDigits\nTP:DoubleToStringtakeProfitDigits;
SendNotificationconfirmText;


else

PrintErreurordreBUYbasbougiesfutures:tradeResultRetcodetradeResultRetcodeDescription;

Envoyernotificationderreur
ifDisableNotifications

stringerrorText=ERREURBUY\nSymbol\nCode:IntegerToStringtradeResultRetcode\ntradeResultRetcodeDescription;
SendNotificationerrorText;



elseSELL

EnvoyernotificationAVANTlexcutiondelordre
ifDisableNotifications

stringnotificationText=SELLFutureCandlesAI\nSymbol@DoubleToStringcurrentPriceDigits\nConfiance:DoubleToStringconfidence1001\nPositionOUVERTEIMMDIATEMENT;
SendNotificationnotificationText;
AlertnotificationText;


Excuterlordreimmdiatementaprslanotification
iftradeSelllotSizeSymbolcurrentPricestopLosstakeProfitorderComment

doubleriskUSD=slDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=tpDistancelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintORDRESELLBASBOUGIESFUTURESPOSITIONOUVERTE:;
PrintDirection:SELLconfiance:DoubleToStringconfidence1001;
PrintPrixdentre:DoubleToStringcurrentPriceDigits;
PrintStopLoss:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTakeProfit:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;
PrintTaille:DoubleToStringlotSize2;
PrintBassurprdictiondesbougiesfuturessurEnumToStringENUMTIMEFRAMESPeriod;
PrintPositionouverteIMMDIATEMENTaprsnotification;

Envoyernotificationdeconfirmation
ifDisableNotifications

stringconfirmText=SELLEXECUT\nSymbol@DoubleToStringcurrentPriceDigits\nSL:DoubleToStringstopLossDigits\nTP:DoubleToStringtakeProfitDigits;
SendNotificationconfirmText;


else

PrintErreurordreSELLbasbougiesfutures:tradeResultRetcodetradeResultRetcodeDescription;

Envoyernotificationderreur
ifDisableNotifications

stringerrorText=ERREURSELL\nSymbol\nCode:IntegerToStringtradeResultRetcode\ntradeResultRetcodeDescription;
SendNotificationerrorText;






Scurisationdynamiquedesprofits
Activedsqueleprofittotal>=3
Fermelespositionssiprofit<50duprofitmax
SinondplaceleSLpourscuriserlesprofits


Trouveroucreruntrackerdeprofitpouruneposition

doubleGetMaxProfitForPositionulongticket

Chercherdansletableaudetrackers
forinti=0;i<gprofitTrackersCount;i

ifgprofitTrackers[iticket==ticket
returngprofitTrackers[imaxProfit;


Sipastrouvcrerunnouveautracker
ifgprofitTrackersCount>=ArraySizegprofitTrackers

intnewSize=gprofitTrackersCount10;
ArrayResizegprofitTrackersnewSize;


gprofitTrackers[gprofitTrackersCountticket=ticket;
gprofitTrackers[gprofitTrackersCountmaxProfit=00;
gprofitTrackers[gprofitTrackersCountlastUpdate=TimeCurrent;
gprofitTrackersCount;

return00;



Mettrejourleprofitmaxpouruneposition

voidUpdateMaxProfitForPositionulongticketdoublecurrentProfit

Chercherdansletableau
forinti=0;i<gprofitTrackersCount;i

ifgprofitTrackers[iticket==ticket

ifcurrentProfit>gprofitTrackers[imaxProfit

gprofitTrackers[imaxProfit=currentProfit;
gprofitTrackers[ilastUpdate=TimeCurrent;

return;



Sipastrouvcrerunnouveautracker
ifgprofitTrackersCount>=ArraySizegprofitTrackers

intnewSize=gprofitTrackersCount10;
ArrayResizegprofitTrackersnewSize;


gprofitTrackers[gprofitTrackersCountticket=ticket;
gprofitTrackers[gprofitTrackersCountmaxProfit=MathMaxcurrentProfit00;
gprofitTrackers[gprofitTrackersCountlastUpdate=TimeCurrent;
gprofitTrackersCount;



Nettoyerlestrackersdepositionsfermes

voidCleanupProfitTrackers

Vrifierquellespositionsexistentencore
ulongactiveTickets[;
intactiveCount=0;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

ArrayResizeactiveTicketsactiveCount1;
activeTickets[activeCount=ticket;
activeCount;




Supprimerlestrackersdespositionsfermes
intwriteIndex=0;
forinti=0;i<gprofitTrackersCount;i

boolfound=false;
forintj=0;j<activeCount;j

ifgprofitTrackers[iticket==activeTickets[j

found=true;
break;



iffound

ifwriteIndex=i

gprofitTrackers[writeIndex=gprofitTrackers[i;

writeIndex;



gprofitTrackersCount=writeIndex;



Scuriserleprofitdunepositionindividuelle
DplaceleSLpourscuriseraumoins50duprofitactuel
Appeldsquunepositionestenprofit

voidSecureProfitForPositionulongticketdoublecurrentProfit

ifpositionInfoSelectByTicketticket
return;

Nescuriserquesiprofit>010vitertropdemodifications
ifcurrentProfit<=010
return;

doubleopenPrice=positionInfoPriceOpen;
doublecurrentPrice=positionInfoPriceCurrent;
doublecurrentSL=positionInfoStopLoss;
ENUMPOSITIONTYPEposType=positionInfoPositionType;
doublelotSize=positionInfoVolume;

Calculerleprofitscuriser50duprofitactuel
doubleprofitToSecure=currentProfit050;

Convertirleprofitenpoints
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doubletickValue=SymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doublepointValue=tickValuetickSizepoint;

doublepointsToSecure=0;
ifpointValue>0lotSize>0

doubleprofitPerPoint=lotSizepointValue;
ifprofitPerPoint>0
pointsToSecure=profitToSecureprofitPerPoint;


SilecalculchoueutiliserATRcommefallback
ifpointsToSecure<=0

doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

UtiliserunefractiondelATRbasesurleprofit
ifpointValue>0lotSize>0

doubleprofitPerATR=lotSizepointValueatr[0point;
ifprofitPerATR>0
pointsToSecure=profitToSecureprofitPerATRatr[0point;



ifpointsToSecure<=0
return;Impossibledecalculerabandonner


CalculerlenouveauSL
doublenewSL=00;
boolshouldUpdate=false;

ifposType==POSITIONTYPEBUY

BUY:SL=prixdentreprofitscuris
newSL=NormalizeDoubleopenPricepointsToSecurepointDigits;

LenouveauSLdoittremeilleurplushautquelactuel
ifcurrentSL==0newSL>currentSL
shouldUpdate=true;

elseSELL

SELL:SL=prixdentreprofitscuris
newSL=NormalizeDoubleopenPricepointsToSecurepointDigits;

LenouveauSLdoittremeilleurplusbasquelactuel
ifcurrentSL==0newSL<currentSL
shouldUpdate=true;


ifshouldUpdate
return;SLdjmeilleurougal

Vrifierlesniveauxminimumsdubroker
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=stopLevelpoint;
ifminDistance==0minDistance<tickSize
minDistance=MathMaxtickSize35point;

VrifierqueleSLrespecteladistanceminimum
boolslValid=false;
ifposType==POSITIONTYPEBUY

slValid=newSL<=currentPriceminDistancenewSL>openPrice;

else

slValid=newSL>=currentPriceminDistancenewSL<openPrice;


ifslValid

ifDebugMode
PrintSLscurisationtropprocheduprixactuelDoubleToStringnewSLDigitsvsDoubleToStringcurrentPriceDigits;
return;


MettrejourleSL
doubletp=positionInfoTakeProfit;
iftradePositionModifyticketnewSLtp

PrintProfitscuris:SLdplacpourscuriserDoubleToStringprofitToSecure250deDoubleToStringcurrentProfit2NouveauSL:DoubleToStringnewSLDigits;
ifgpositionTrackerticket==ticket
gpositionTrackerprofitSecured=true;

elseifDebugMode

PrintErreurscurisationprofit:tradeResultRetcodeDescription;




Scurisationdynamiquedesprofits
Activedsqueleprofittotal>=3
Fermelespositionssiprofit<50duprofitmax
SinondplaceleSLpourscuriserlesprofits

voidSecureDynamicProfits

DEBUG:Confirmerlappeldelafonctionmoinsfrquent
staticdatetimelastDebug=0;
ifTimeCurrentlastDebug>=60Toutesles60secondesaulieude30

ifDebugMode
PrintSecureDynamicProfitsappelTrailingstopACTIF;
lastDebug=TimeCurrent;


OPTIMISATION:Sortirrapidesiaucuneposition
ifPositionsTotal==0
return;

0SORTIERAPIDEPOURINDICESVOLATILITY
FermerchaquepositionVolatilitydsqueleprofitatteintVolatilityQuickTPex:2
boolisVolatilitySymbol=IsVolatilitySymbolSymbol;
ifisVolatilitySymbolVolatilityQuickTP>00

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

doubleprofit=positionInfoProfit;

Fermerdsqueleprofitatteintleseuilrapide
ifprofit>=VolatilityQuickTP

iftradePositionCloseticket

PrintVolatility:PositionfermeTPrapideDoubleToStringVolatilityQuickTP2
profit=DoubleToStringprofit2Prisedegainrapideprtsereplacersilemouvementcontinue;
Continuerlabouclepourgrerdautrespositionssibesoin
continue;

elseifDebugMode

PrintErreurfermeturepositionVolatilityTPrapide:
tradeResultRetcodetradeResultRetcodeDescription;







Nettoyerlestrackersdepositionsfermes
staticdatetimelastCleanup=0;
ifTimeCurrentlastCleanup>60Touteslesminutes

CleanupProfitTrackers;
lastCleanup=TimeCurrent;


Calculerleprofittotaldetouteslespositions
doubletotalProfit=00;
intprofitablePositions=0;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

doubleprofit=positionInfoProfit;
totalProfit=profit;

Mettrejourleprofitmaxpourcetteposition
UpdateMaxProfitForPositionticketprofit;

ifprofit>0
profitablePositions;




Mettrejourleprofitmaximumglobal
iftotalProfit>gglobalMaxProfit
gglobalMaxProfit=totalProfit;

NOUVELLELOGIQUE:ScurisationAGGRESSIVEdsquunepositionestenprofit
Onscurisechaquepositionindividuellementdsquelleestenprofit
Plusbesoindattendre3totalprotectionimmdiatedesgains

Scurisationactive:vrifierchaqueposition
forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

doublecurrentProfit=positionInfoProfit;
doubleopenPrice=positionInfoPriceOpen;
doublecurrentPrice=positionInfoPriceCurrent;
doublecurrentSL=positionInfoStopLoss;
ENUMPOSITIONTYPEposType=positionInfoPositionType;

NOUVELLELOGIQUE:ScurisationAGGRESSIVEdsquilyaunprofit
Dsquunepositionestenprofitonscuriseaumoins50desgainsinitiaux

Rcuprerleprofitmaxpourcetteposition
doublemaxProfitForPosition=GetMaxProfitForPositionticket;
ifmaxProfitForPosition==00currentProfit>0
maxProfitForPosition=currentProfit;Utiliserleprofitactuelcommerfrenceinitiale

SCURISATIONIMMDIATE:Dsquilyaunprofitmmepetitscuriser50
ifcurrentProfit>0

UtiliserleprofitactuelOUleprofitmaxlepluslev
doubleprofitReference=MathMaxcurrentProfitmaxProfitForPosition;

Calculerledrawdownenpourcentage
doubledrawdownPercent=00;
ifprofitReference>0
drawdownPercent=profitReferencecurrentProfitprofitReference;

Sidrawdown>50fermerlapositionprotectioncontreretournement
FIX:Ajouterunseuilminimumdeprofit20avantdefermersurdrawdown
Celavitedefermerunepositionquipassede050020drawdown>50maisinsignifiant
doubleMINPROFITFORDRAWDOWNCLOSE=20;

ifdrawdownPercent>PROFITDRAWDOWNLIMITprofitReference>MINPROFITFORDRAWDOWNCLOSEcurrentProfit>0

iftradePositionCloseticket

PrintPositionfermeDrawdown>50:Profitmax=DoubleToStringprofitReference2
Profitactuel=DoubleToStringcurrentProfit2Drawdown=DoubleToStringdrawdownPercent1001;

continue;


SCURISATIONPROGRESSIVE:DplacerleSLpourscuriseraumoins50duprofitactuel
Onscurise50duprofitactuelpasseulementduprofitmax
doubleprofitToSecure=currentProfit050;50duprofitactuelAGGRESSIF

Convertirleprofitenpoints
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doubletickValue=SymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doubletickSize=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doublepointValue=tickValuetickSizepoint;
doublelotSize=positionInfoVolume;

doublepointsToSecure=0;
ifpointValue>0lotSize>0

doubleprofitPerPoint=lotSizepointValue;
ifprofitPerPoint>0
pointsToSecure=profitToSecureprofitPerPoint;


SilecalculchoueutiliserATRcommefallback
ifpointsToSecure<=0

doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0
pointsToSecure=profitToSecurelotSizepointValue>0?profitToSecurelotSizepointValue:atr[0point;


CalculerlenouveauSLpourscuriser50duprofitactuel
doublenewSL=00;

Calculerleprixquicorrespond50duprofitactuel
PourBUY:SL=prixdentreprofitscurisenpoints
PourSELL:SL=prixdentreprofitscurisenpoints

ifposType==POSITIONTYPEBUY

BUY:SLdoittreaudessusduprixdentrepourscuriserleprofit
newSL=openPricepointsToSecurepoint;

LenouveauSLdoittremeilleurplushautquelactuel
ETnepastretropprocheduprixactuel
boolshouldUpdate=false;
ifcurrentSL==0

PasdeSLactuelonpeutenmettreun
shouldUpdate=true;

elseifnewSL>currentSL

LenouveauSLestmeilleurplushautquelactuel
shouldUpdate=true;


ifshouldUpdate

Vrifierlesniveauxminimumsdubroker
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubletickSizeLocal=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doubleminDistance=stopLevelpoint;
ifminDistance==0minDistance<tickSizeLocal
minDistance=MathMaxtickSizeLocal35point;

LeSLdoittreaumoinsminDistanceendessousduprixactuel
ifnewSL<=currentPriceminDistance

doubletp=positionInfoTakeProfit;
iftradePositionModifyticketnewSLtp

PrintSLscurisBUY:DoubleToStringnewSLDigits
scuriseDoubleToStringprofitToSecure2=50deDoubleToStringcurrentProfit2;
ifgpositionTrackerticket==ticket
gpositionTrackerprofitSecured=true;

elseifDebugMode

PrintErreurmodificationSLBUY:tradeResultRetcodeDescription;


elseifDebugMode

PrintSLBUYtropprocheduprixactuelDoubleToStringnewSLDigitsvsDoubleToStringcurrentPriceDigits;



elseSELL

SELL:SLdoittreendessousduprixdentrepourscuriserleprofit
newSL=openPricepointsToSecurepoint;

LenouveauSLdoittremeilleurplusbasquelactuel
ETnepastretropprocheduprixactuel
boolshouldUpdate=false;
ifcurrentSL==0

PasdeSLactuelonpeutenmettreun
shouldUpdate=true;

elseifnewSL<currentSL

LenouveauSLestmeilleurplusbasquelactuel
shouldUpdate=true;


ifshouldUpdate

Vrifierlesniveauxminimumsdubroker
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubletickSizeLocal=SymbolInfoDoubleSymbolSYMBOLTRADETICKSIZE;
doubleminDistance=stopLevelpoint;
ifminDistance==0minDistance<tickSizeLocal
minDistance=MathMaxtickSizeLocal35point;

LeSLdoittreaumoinsminDistanceaudessusduprixactuel
ifnewSL>=currentPriceminDistance

doubletp=positionInfoTakeProfit;
iftradePositionModifyticketnewSLtp

PrintSLscurisSELL:DoubleToStringnewSLDigits
scuriseDoubleToStringprofitToSecure2=50deDoubleToStringcurrentProfit2;
ifgpositionTrackerticket==ticket
gpositionTrackerprofitSecured=true;

elseifDebugMode

PrintErreurmodificationSLSELL:tradeResultRetcodeDescription;


elseifDebugMode

PrintSLSELLtropprocheduprixactuelDoubleToStringnewSLDigitsvsDoubleToStringcurrentPriceDigits;








Sileprofitglobalachutdeplusde50fermertouteslespositionsgagnantes
ifgglobalMaxProfit>0totalProfit<gglobalMaxProfitPROFITDRAWDOWNLIMIT

ifDebugMode
PrintDrawdownglobal>50Fermeturedetouteslespositionsgagnantes;

forinti=PositionsTotal1;i>=0;i

ulongticket=PositionGetTicketi;
ifticket>0positionInfoSelectByTicketticket

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

doubleprofit=positionInfoProfit;
ifprofit>0

iftradePositionCloseticket

PrintPositiongagnantefermedrawdownglobal:DoubleToStringprofit2;






Rinitialiserleprofitmaxglobal
gglobalMaxProfit=00;




CalculelaforcedumomentumMCSMomentumConceptStrategy
Retourneunscoreentre00et10

doubleCalculateMomentumStrengthENUMORDERTYPEorderTypeintlookbackBars=5

doublemomentum=00;

Rcuprerlesdonnesdeprix
doubleclose[;
ArraySetAsSeriesclosetrue;
ifCopyCloseSymbolPERIODCURRENT0lookbackBars2close<lookbackBars2
return00;

RcuprerlATRpournormaliser
doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr<=0
return00;

Compterlesbougiesdirectionnelles
intbullishBars=0;
intbearishBars=0;
doubletotalMovement=00;

forinti=0;i<lookbackBars;i

doublemovement=MathAbsclose[iclose[i1;
totalMovement=movement;

ifclose[i>close[i1
bullishBars;
elseifclose[i<close[i1
bearishBars;


doubleavgMovement=lookbackBars>0?totalMovementlookbackBars:00;
doublenormalizedMovement=atr[0>0?avgMovementatr[0:00;

Calculerlemomentumdirectionnel
doubledirectionalBias=00;
iforderType==ORDERTYPEBUY

directionalBias=doublebullishBarslookbackBars;
momentum=normalizedMovementdirectionalBias;

elseSELL

directionalBias=doublebearishBarslookbackBars;
momentum=normalizedMovementdirectionalBias;


Ajouterunfacteurdevitesseacclration
iflookbackBars>=3

doublerecentMovement=MathAbsclose[0close[2;
doubleolderMovement=MathAbsclose[2close[4;
ifolderMovement>0

doubleacceleration=recentMovementolderMovement;
momentum=MathMinacceleration20;Limiter2x



Normaliserentre00et10
momentum=MathMinMathMaxmomentum200010;

returnmomentum;



AnalyseleszonesdepressionMCSMomentumConceptStrategy
BassurleszonesAIetlemomentum
Retourne:truesizonedepressionvalideavecmomentumsuffisant

boolAnalyzeMomentumPressureZoneENUMORDERTYPEorderTypedoublepricedoublemomentumScoredoublezoneStrength

momentumScore=00;
zoneStrength=00;

1VrifiersionestdansunezoneAIBUYSELL
boolinZone=false;
boolisBuyZone=false;

iforderType==ORDERTYPEBUYgaiBuyZoneLow>0gaiBuyZoneHigh>0

ifprice>=gaiBuyZoneLowprice<=gaiBuyZoneHigh

inZone=true;
isBuyZone=true;
Forcedelazonebasesurlaproximitducentre
doublezoneCenter=gaiBuyZoneLowgaiBuyZoneHigh20;
doublezoneRange=gaiBuyZoneHighgaiBuyZoneLow;
ifzoneRange>0

doubledistanceFromCenter=MathAbspricezoneCenterzoneRange;
zoneStrength=10distanceFromCenter20;Plusprocheducentre=plusfort
zoneStrength=MathMax03MathMin10zoneStrength;

else
zoneStrength=05;


elseiforderType==ORDERTYPESELLgaiSellZoneLow>0gaiSellZoneHigh>0

ifprice>=gaiSellZoneLowprice<=gaiSellZoneHigh

inZone=true;
isBuyZone=false;
Forcedelazonebasesurlaproximitducentre
doublezoneCenter=gaiSellZoneLowgaiSellZoneHigh20;
doublezoneRange=gaiSellZoneHighgaiSellZoneLow;
ifzoneRange>0

doubledistanceFromCenter=MathAbspricezoneCenterzoneRange;
zoneStrength=10distanceFromCenter20;
zoneStrength=MathMax03MathMin10zoneStrength;

else
zoneStrength=05;



ifinZone
returnfalse;Pasdansunezonedepression

2Calculerlemomentumdanscettezone
momentumScore=CalculateMomentumStrengthorderType5;

3Vrifierquelemomentumestsuffisantminimum03
ifmomentumScore<03
returnfalse;

4Vrifierlaforcedelazoneminimum04
ifzoneStrength<04
returnfalse;

Zonedepressionvalideavecmomentumsuffisant
returntrue;



DtecterretournementsurEMArapideM5pourBoomCrash
VrifieaussilalignementM5H1avantdautoriserlentre

boolDetectBoomCrashReversalAtEMAENUMORDERTYPEorderType

ifIsBoomCrashSymbolSymbol
returnfalse;

PROTECTION:BloquerSELLsurBoometBUYsurCrash
boolisBoom=StringFindSymbolBoom=1;
boolisCrash=StringFindSymbolCrash=1;

ifisBoomorderType==ORDERTYPESELL

ifDebugMode
PrintBoomCrash:ImpossibledetraderSELLsurSymbolBoom=BUYuniquement;
returnfalse;


ifisCrashorderType==ORDERTYPEBUY

ifDebugMode
PrintBoomCrash:ImpossibledetraderBUYsurSymbolCrash=SELLuniquement;
returnfalse;


1VrifierlalignementM5H1dabord
ifCheckTrendAlignmentorderType

ifDebugMode
PrintBoomCrash:AlignementM5H1nonconfirmpourEnumToStringorderType;
returnfalse;


2RcuprerEMArapideM5etprix
doubleemaFastM5[;
ArraySetAsSeriesemaFastM5true;
ifCopyBufferemaFastM5Handle005emaFastM5<5

ifDebugMode
PrintBoomCrash:ErreurrcuprationEMArapideM5;
returnfalse;


doubleprice=orderType==ORDERTYPEBUY?
SymbolInfoDoubleSymbolSYMBOLASK:
SymbolInfoDoubleSymbolSYMBOLBID;

RcuprerlesprixhistoriquesM5
doublecloseM5[highM5[lowM5[;
ArraySetAsSeriescloseM5true;
ArraySetAsSerieshighM5true;
ArraySetAsSerieslowM5true;

ifCopyCloseSymbolPERIODM505closeM5<5
CopyHighSymbolPERIODM505highM5<5
CopyLowSymbolPERIODM505lowM5<5

ifDebugMode
PrintBoomCrash:ErreurrcuprationprixM5;
returnfalse;


Calculerladistanceauprixenpoints
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doubletolerance=10point;Tolrancede10pointsautourdelEMA

3DtecterretournementpourBUYBoom
iforderType==ORDERTYPEBUY

LeprixdoittreprochedelEMArapideM5endessousoulgrementaudessus
ifprice>=emaFastM5[0toleranceprice<=emaFastM5[0tolerance

Vrifierqueleprixabaisspuisrebondi
boolwasDown=false;
boolisRebounding=false;

Vrifierbaisse:prixprcdentendessousdelEMAouprixquidescend
ifcloseM5[1<emaFastM5[1closeM5[2<emaFastM5[2lowM5[1<emaFastM5[1
wasDown=true;

Vrifierrebond:prixactuelremonteoutouchelEMAdepuislebas
ifcloseM5[0>closeM5[1lowM5[0<=emaFastM5[0closeM5[0>=emaFastM5[0
isRebounding=true;

ifwasDownisRebounding

Estimerletempsjusquauspikegnralement515secondespourBoomCrash
intestimatedSeconds=10;Estimationpardfaut
ifDebugMode
PrintBoomCrashBUY:RetournementdtectsurEMArapideM5SpikeestimdansestimatedSecondssecondes;

Envoyeralerte
AlertSPIKEBOOMDTECT:SymbolEntredansestimatedSecondssecondes;

returntrue;



4DtecterretournementpourSELLCrash
elseiforderType==ORDERTYPESELL

LeprixdoittreprochedelEMArapideM5audessusoulgrementendessous
ifprice>=emaFastM5[0toleranceprice<=emaFastM5[0tolerance

Vrifierqueleprixamontpuisrebondilabaisse
boolwasUp=false;
boolisRebounding=false;

Vrifierhausse:prixprcdentaudessusdelEMAouprixquimonte
ifcloseM5[1>emaFastM5[1closeM5[2>emaFastM5[2highM5[1>emaFastM5[1
wasUp=true;

Vrifierrebondbaissier:prixactuelredescendoutouchelEMAdepuislehaut
ifcloseM5[0<closeM5[1highM5[0>=emaFastM5[0closeM5[0<=emaFastM5[0
isRebounding=true;

ifwasUpisRebounding

Estimerletempsjusquauspike
intestimatedSeconds=10;Estimationpardfaut
ifDebugMode
PrintBoomCrashSELL:RetournementdtectsurEMArapideM5SpikeestimdansestimatedSecondssecondes;

Envoyeralerte
AlertSPIKECRASHDTECT:SymbolEntredansestimatedSecondssecondes;

returntrue;




returnfalse;


TentativedentrespikesurBoomCrashavecconfianceIAminimale60etretournementEMAM5
boolTrySpikeEntryENUMORDERTYPEorderType

ifIsBoomCrashSymbolSymbol
returnfalse;

ConfianceIAminimale60pourBoomCrash
ifglastAIConfidence<060
returnfalse;

intidx=GetSpikeIndexSymbol;
datetimenow=TimeCurrent;
ifnow<gspikeCooldown[idx

ifDebugMode
PrintSpikecooldownactifpourSymboljusquTimeToStringgspikeCooldown[idx;
returnfalse;


LalignementM5H1adjtvrifidansDetectBoomCrashReversalAtEMA
Icionouvresimplementletradecarleretournementatconfirm

PROTECTION:BloquerSELLsurBoometBUYsurCrash
boolisBoom=StringFindSymbolBoom=1;
boolisCrash=StringFindSymbolCrash=1;

ifisBoomorderType==ORDERTYPESELL

ifDebugMode
PrintTrySpikeEntry:ImpossibleSELLsurBoom;
returnfalse;


ifisCrashorderType==ORDERTYPEBUY

ifDebugMode
PrintTrySpikeEntry:ImpossibleBUYsurCrash;
returnfalse;


Ouvrirletradeimmdiatementleretournementetlalignementsontdjconfirms
ifDebugMode
PrintBoomCrash:OuverturetradeEnumToStringorderTypeaprsretournementEMAM5confirm;

ExecuteTradeorderType;

Incrmenterlestentatives;si2sansspikecooldown5minutes
gspikeFailCount[idx;
ifgspikeFailCount[idx>=2

gspikeCooldown[idx=now300;5minutes
gspikeFailCount[idx=0;
ifDebugMode
PrintCooldown5minpourSymbolaprs2tentativesspike;


returntrue;



VrifiersileprixestdanslazoneIAetsilesEMAconfirment
vitedetraderlescorrectionsAmliorationdesentres


DtecterunretournementauniveaudelEMArapide
RetournetruesileprixrebonditsurlEMArapideaprsbaissehausse

boolDetectReversalAtFastEMAENUMORDERTYPEorderType

RcuprerlEMArapideM1
doubleemaFast[;
ArraySetAsSeriesemaFasttrue;
ifCopyBufferemaFastHandle005emaFast<5

ifDebugMode
PrintErreurrcuprationEMArapidepourdtectionretournement;
returnfalse;


Rcuprerlesprix
doubleclose[high[low[;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;
ifCopyCloseSymbolPERIODM105close<5
CopyHighSymbolPERIODM105high<5
CopyLowSymbolPERIODM105low<5

ifDebugMode
PrintErreurrcuprationprixpourdtectionretournement;
returnfalse;


doublecurrentPrice=orderType==ORDERTYPEBUY?
SymbolInfoDoubleSymbolSYMBOLASK:
SymbolInfoDoubleSymbolSYMBOLBID;

Calculerladistanceauprixenpoints
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doubletolerance=10point;Tolrancede10pointsautourdelEMA

PourBUY:Dtecterrebondhaussieraprsbaisse
iforderType==ORDERTYPEBUY

LeprixdoittreprochedelEMArapideendessousoulgrementaudessus
ifcurrentPrice>=emaFast[0tolerancecurrentPrice<=emaFast[0tolerance

Vrifierqueleprixabaisspuisrebondi
Les23derniresbougiesdoiventmontrerunebaissepuisladernireunrebond
boolwasDown=false;
boolisRebounding=false;

Vrifierbaisse:prixprcdentendessousdelEMAouprixquidescend
ifclose[1<emaFast[1close[2<emaFast[2low[1<emaFast[1
wasDown=true;

Vrifierrebond:prixactuelremonteoutouchelEMAdepuislebas
ifclose[0>close[1low[0<=emaFast[0close[0>=emaFast[0
isRebounding=true;

VrifieraussiquelatendancelongueesthaussireEMA50100200
doubleema50[ema100[ema200[;
ArraySetAsSeriesema50true;
ArraySetAsSeriesema100true;
ArraySetAsSeriesema200true;

ifCopyBufferema50Handle001ema50>0
CopyBufferema100Handle001ema100>0
CopyBufferema200Handle001ema200>0

Vrifieralignementhaussier:EMA50>EMA100>EMA200ouaumoinsEMA50>EMA100
boollongTrendBullish=ema50[0>ema100[0;

ifwasDownisReboundinglongTrendBullish

ifDebugMode
PrintRetournementBUYdtect:PrixrebonditsurEMArapideaprsbaisseEMA50=DoubleToStringema50[0Digits
>EMA100=DoubleToStringema100[0Digits;
returntrue;


elseifwasDownisRebounding

SionnepeutpasvrifierlesEMAlonguesaccepterquandmmesilesautresconditionssontremplies
ifDebugMode
PrintRetournementBUYdtect:PrixrebonditsurEMArapideaprsbaisseEMAlonguesnondisponibles;
returntrue;



PourSELL:Dtecterrebondbaissieraprshausse
elseiforderType==ORDERTYPESELL

LeprixdoittreprochedelEMArapideaudessusoulgrementendessous
ifcurrentPrice>=emaFast[0tolerancecurrentPrice<=emaFast[0tolerance

Vrifierqueleprixamontpuisrebondilabaisse
boolwasUp=false;
boolisRebounding=false;

Vrifierhausse:prixprcdentaudessusdelEMAouprixquimonte
ifclose[1>emaFast[1close[2>emaFast[2high[1>emaFast[1
wasUp=true;

Vrifierrebondbaissier:prixactuelredescendoutouchelEMAdepuislehaut
ifclose[0<close[1high[0>=emaFast[0close[0<=emaFast[0
isRebounding=true;

VrifieraussiquelatendancelongueestbaissireEMA50100200
doubleema50[ema100[ema200[;
ArraySetAsSeriesema50true;
ArraySetAsSeriesema100true;
ArraySetAsSeriesema200true;

ifCopyBufferema50Handle001ema50>0
CopyBufferema100Handle001ema100>0
CopyBufferema200Handle001ema200>0

Vrifieralignementbaissier:EMA50<EMA100<EMA200ouaumoinsEMA50<EMA100
boollongTrendBearish=ema50[0<ema100[0;

ifwasUpisReboundinglongTrendBearish

ifDebugMode
PrintRetournementSELLdtect:PrixrebonditsurEMArapideaprshausseEMA50=DoubleToStringema50[0Digits
<EMA100=DoubleToStringema100[0Digits;
returntrue;


elseifwasUpisRebounding

SionnepeutpasvrifierlesEMAlonguesaccepterquandmmesilesautresconditionssontremplies
ifDebugMode
PrintRetournementSELLdtect:PrixrebonditsurEMArapideaprshausseEMAlonguesnondisponibles;
returntrue;




returnfalse;



VrifiersileprixrebonditsurunetrendlineEMAM5H1
Lestrendlinesserventdesupportrsistancedynamiques
Retour:truesirebonddtectdistanceenpointsdansdistance

boolCheckReboundOnTrendlineENUMORDERTYPEorderTypedoubledistance

distance=00;

RcuprerlesEMAM5etH1lestrendlinessontbasessurcesEMA
doubleemaFastM5[emaSlowM5[emaFastH1[emaSlowH1[;
ArraySetAsSeriesemaFastM5true;
ArraySetAsSeriesemaSlowM5true;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;

ifCopyBufferemaFastM5Handle003emaFastM5<3
CopyBufferemaSlowM5Handle003emaSlowM5<3
CopyBufferemaFastH1Handle003emaFastH1<3
CopyBufferemaSlowH1Handle003emaSlowH1<3

ifDebugMode
PrintErreurrcuprationEMAM5H1pourvrificationtrendline;
returnfalse;


Rcuprerlesprixhistoriques
doubleclose[high[low[;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;

ifCopyCloseSymbolPERIODM105close<5
CopyHighSymbolPERIODM105high<5
CopyLowSymbolPERIODM105low<5

returnfalse;


doublecurrentPrice=orderType==ORDERTYPEBUY?
SymbolInfoDoubleSymbolSYMBOLBID:
SymbolInfoDoubleSymbolSYMBOLASK;

doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doubletoleranceM5=15point;Tolrancede15pointspourEMAM5
doubletoleranceH1=30point;Tolrancede30pointspourEMAH1pluslargecartimeframepluslong

PourBUY:VrifierrebondsurtrendlinedesupportEMA
iforderType==ORDERTYPEBUY

VrifierrebondsurEMAFastM5trendlinedesupportcourtterme
doubledistanceToEMAFastM5=MathAbscurrentPriceemaFastM5[0;
boolnearEMAFastM5=currentPrice>=emaFastM5[0toleranceM5currentPrice<=emaFastM5[0toleranceM5;

VrifierquelEMAM5esthaussireEMAFast>EMASlow
boolemaMBullish=emaFastM5[0>emaSlowM5[0;

VrifierquelEMAH1esthaussireconfirmationtendancelongterme
boolemaH1Bullish=emaFastH1[0>emaSlowH1[0;

Vrifierqueleprixvientderebondirtaitendessouspuisremonte
boolwasBelow=close[1<emaFastM5[1close[2<emaFastM5[2low[1<emaFastM5[1;
boolisRebounding=close[0>close[1low[0<=emaFastM5[0close[0>=emaFastM5[0;

RebondsurEMAFastM5prioritcarplusractif
ifnearEMAFastM5emaMBullishwasBelowisRebounding

VrifierconfirmationH1
ifemaH1Bullish

distance=distanceToEMAFastM5point;
ifDebugMode
PrintRebondBUYsurtrendlineEMAFastM5dtectdistance:DoubleToStringdistance0pointsTendanceH1confirme;
returntrue;

else

EMAH1nonalignemaisEMAM5OK=signalmoyen
distance=distanceToEMAFastM5point;
ifDebugMode
PrintRebondBUYsurEMAFastM5maisH1nonalignedistance:DoubleToStringdistance0pointsSignalmoyen;
returntrue;Accepterquandmmemaissignalmoinsfort



VrifieraussirebondsurEMAFastH1supportlongtermemoinsfrquentmaisplusfort
doubledistanceToEMAFastH1=MathAbscurrentPriceemaFastH1[0;
boolnearEMAFastH1=currentPrice>=emaFastH1[0toleranceH1currentPrice<=emaFastH1[0toleranceH1;

ifnearEMAFastH1emaH1BullishemaMBullish

Vrifierqueleprixrebondit
boolwasBelowH1=close[1<emaFastH1[1close[2<emaFastH1[2low[1<emaFastH1[1;
boolisReboundingH1=close[0>close[1low[0<=emaFastH1[0close[0>=emaFastH1[0;

ifwasBelowH1isReboundingH1

distance=distanceToEMAFastH1point;
ifDebugMode
PrintRebondBUYsurtrendlineEMAFastH1dtectdistance:DoubleToStringdistance0pointsSignaltrsfort;
returntrue;



PourSELL:VrifierrebondsurtrendlinedersistanceEMA
elseiforderType==ORDERTYPESELL

VrifierrebondsurEMAFastM5trendlinedersistancecourtterme
doubledistanceToEMAFastM5=MathAbscurrentPriceemaFastM5[0;
boolnearEMAFastM5=currentPrice>=emaFastM5[0toleranceM5currentPrice<=emaFastM5[0toleranceM5;

VrifierquelEMAM5estbaissireEMAFast<EMASlow
boolemaMBearish=emaFastM5[0<emaSlowM5[0;

VrifierquelEMAH1estbaissireconfirmationtendancelongterme
boolemaH1Bearish=emaFastH1[0<emaSlowH1[0;

Vrifierqueleprixvientderebondirtaitaudessuspuisredescend
boolwasAbove=close[1>emaFastM5[1close[2>emaFastM5[2high[1>emaFastM5[1;
boolisRebounding=close[0<close[1high[0>=emaFastM5[0close[0<=emaFastM5[0;

RebondsurEMAFastM5prioritcarplusractif
ifnearEMAFastM5emaMBearishwasAboveisRebounding

VrifierconfirmationH1
ifemaH1Bearish

distance=distanceToEMAFastM5point;
ifDebugMode
PrintRebondSELLsurtrendlineEMAFastM5dtectdistance:DoubleToStringdistance0pointsTendanceH1confirme;
returntrue;

else

EMAH1nonalignemaisEMAM5OK=signalmoyen
distance=distanceToEMAFastM5point;
ifDebugMode
PrintRebondSELLsurEMAFastM5maisH1nonalignedistance:DoubleToStringdistance0pointsSignalmoyen;
returntrue;Accepterquandmmemaissignalmoinsfort



VrifieraussirebondsurEMAFastH1rsistancelongtermemoinsfrquentmaisplusfort
doubledistanceToEMAFastH1=MathAbscurrentPriceemaFastH1[0;
boolnearEMAFastH1=currentPrice>=emaFastH1[0toleranceH1currentPrice<=emaFastH1[0toleranceH1;

ifnearEMAFastH1emaH1BearishemaMBearish

Vrifierqueleprixrebondit
boolwasAboveH1=close[1>emaFastH1[1close[2>emaFastH1[2high[1>emaFastH1[1;
boolisReboundingH1=close[0<close[1high[0>=emaFastH1[0close[0<=emaFastH1[0;

ifwasAboveH1isReboundingH1

distance=distanceToEMAFastH1point;
ifDebugMode
PrintRebondSELLsurtrendlineEMAFastH1dtectdistance:DoubleToStringdistance0pointsSignaltrsfort;
returntrue;




returnfalse;



VrifierentredanszoneIAavecconfirmationEMA

boolCheckAIZoneEntryWithEMAENUMORDERTYPEorderTypeboolisInZoneboolemaConfirmedboolisCorrection

isInZone=false;
emaConfirmed=false;
isCorrection=false;

doublecurrentPrice=orderType==ORDERTYPEBUY?
SymbolInfoDoubleSymbolSYMBOLBID:
SymbolInfoDoubleSymbolSYMBOLASK;

Rcuprerlesprixhistoriquespourvrifierladirectiondentre
doubleclose[high[low[;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;

ifCopyCloseSymbolPERIODM105close<5
CopyHighSymbolPERIODM105high<5
CopyLowSymbolPERIODM105low<5

ifDebugMode
PrintErreurrcuprationdonnesprixM1;
returnfalse;


1VrifiersileprixestdanslazoneIAetladirectiondentre
boolpriceEnteringZone=false;

iforderType==ORDERTYPEBUY

ifgaiBuyZoneLow>0gaiBuyZoneHigh>0

Leprixdoittredanslazonedachat
ifcurrentPrice>=gaiBuyZoneLowcurrentPrice<=gaiBuyZoneHigh

isInZone=true;

Vrifierqueleprixvientdentrerdanslazonedepuislebascorrectiontermine
Leprixprcdentdoittreendessousougallazone
ifclose[1<=gaiBuyZoneHighlow[1<=gaiBuyZoneHigh

priceEnteringZone=true;


Ouleprixtouchelazonedepuislebasretest
elseifcurrentPrice>=gaiBuyZoneLow5PointcurrentPrice<gaiBuyZoneLow

Leprixtouchelebasdelazonedepuislebas
iflow[0<=gaiBuyZoneLowlow[1<=gaiBuyZoneLow

isInZone=true;
priceEnteringZone=true;




elseiforderType==ORDERTYPESELL

ifgaiSellZoneLow>0gaiSellZoneHigh>0

Leprixdoittredanslazonedevente
ifcurrentPrice>=gaiSellZoneLowcurrentPrice<=gaiSellZoneHigh

isInZone=true;

Vrifierqueleprixvientdentrerdanslazonedepuislehautcorrectiontermine
Leprixprcdentdoittreaudessusougallazone
ifclose[1>=gaiSellZoneLowhigh[1>=gaiSellZoneLow

priceEnteringZone=true;


Ouleprixtouchelazonedepuislehautretest
elseifcurrentPrice<=gaiSellZoneHigh5PointcurrentPrice>gaiSellZoneHigh

Leprixtouchelehautdelazonedepuislehaut
ifhigh[0>=gaiSellZoneHighhigh[1>=gaiSellZoneHigh

isInZone=true;
priceEnteringZone=true;





ifisInZonepriceEnteringZone

ifDebugModeisInZone
PrintEnumToStringorderTyperejet:PrixpasdanszoneIA;
elseifDebugModepriceEnteringZone
PrintEnumToStringorderTyperejet:Prixdanszonemaisnentrepasdepuislabonnedirection;
returnfalse;


2RcuprerlesEMAM1M5etH1RSI
doubleemaFastM1[emaSlowM1[emaFastM5[emaSlowM5[emaFastH1[emaSlowH1[rsi[;
ArraySetAsSeriesemaFastM1true;
ArraySetAsSeriesemaSlowM1true;
ArraySetAsSeriesemaFastM5true;
ArraySetAsSeriesemaSlowM5true;
ArraySetAsSeriesemaFastH1true;
ArraySetAsSeriesemaSlowH1true;
ArraySetAsSeriesrsitrue;

RcuprerlesvaleursEMAM1pourdtecterlescorrections
ifCopyBufferemaFastHandle005emaFastM1<=0
CopyBufferemaSlowHandle005emaSlowM1<=0

ifDebugMode
PrintErreurrcuprationEMAM1pourvrificationzone;
returnfalse;


RcuprerlesvaleursEMAM5confirmationprincipale
ifCopyBufferemaFastM5Handle001emaFastM5<=0
CopyBufferemaSlowM5Handle001emaSlowM5<=0

ifDebugMode
PrintErreurrcuprationEMAM5pourvrificationzone;
returnfalse;


RcuprerlesvaleursEMAH1tendancegnrale
ifCopyBufferemaFastH1Handle001emaFastH1<=0
CopyBufferemaSlowH1Handle001emaSlowH1<=0

ifDebugMode
PrintErreurrcuprationEMAH1pourvrificationzone;
returnfalse;


RcuprerRSIpourconfirmationsupplmentaire
ifCopyBufferrsiHandle001rsi<=0

ifDebugMode
PrintErreurrcuprationRSI;
RSInoncritiquecontinuer


3Dtectersionestencorrection
iforderType==ORDERTYPEBUY

PourBUY:correction=leprixdescendEMArapide<EMAlentesurM1
ETleprixactuelestendessousdelEMArapide
boolemaBearishM1=emaFastM1[0<emaSlowM1[0;
boolpriceBelowEMA=currentPrice<emaFastM1[0;

Correctionsi:EMAbaissierETprixsousEMAETles2derniresbougiestaienthaussires
ifemaBearishM1priceBelowEMA

Vrifiersicestunecorrectionrcenteles23derniresbougiesmontaient
boolwasRising=emaFastM1[1>emaFastM1[2emaFastM1[2>emaFastM1[3;
ifwasRising

isCorrection=true;
ifDebugMode
PrintCorrectiondtectepourBUY:Prix=currentPriceEMAFastM1=emaFastM1[0<EMASlowM1=emaSlowM1[0;



ConfirmationEMAM5:EMArapidedoittre>=EMAlentetendancehaussire
emaConfirmed=emaFastM5[0>=emaSlowM5[0;

Confirmationsupplmentaire:RSInedoitpastresurachet>70
boolrsiOk=ArraySizersi>0rsi[0<70;

PourBUY:confirmationM5requise
ifemaConfirmed

ifDebugMode
PrintBUYrejet:EMAM5nonconfirmeFast=emaFastM5[0<Slow=emaSlowM5[0;
returnfalse;


ifrsiOkArraySizersi>0DebugMode
PrintBUY:RSIsurachetDoubleToStringrsi[02maisEMAM5confirme;

elseSELL

PourSELL:correction=leprixmonteEMArapide>EMAlentesurM1
ETleprixactuelestaudessusdelEMArapide
boolemaBullishM1=emaFastM1[0>emaSlowM1[0;
boolpriceAboveEMA=currentPrice>emaFastM1[0;

Correctionsi:EMAhaussierETprixaudessusEMAETles2derniresbougiesdescendaient
ifemaBullishM1priceAboveEMA

Vrifiersicestunecorrectionrcenteles23derniresbougiesdescendaient
boolwasFalling=emaFastM1[1<emaFastM1[2emaFastM1[2<emaFastM1[3;
ifwasFalling

isCorrection=true;
ifDebugMode
PrintCorrectiondtectepourSELL:Prix=currentPriceEMAFastM1=emaFastM1[0>EMASlowM1=emaSlowM1[0;



ConfirmationEMAM5:EMArapidedoittre<=EMAlentetendancebaissire
emaConfirmed=emaFastM5[0<=emaSlowM5[0;

Confirmationsupplmentaire:RSInedoitpastresurvendu<30
boolrsiOk=ArraySizersi>0rsi[0>30;

PourSELL:confirmationM5requise
ifemaConfirmed

ifDebugMode
PrintSELLrejet:EMAM5nonconfirmeFast=emaFastM5[0>Slow=emaSlowM5[0;
returnfalse;


ifrsiOkArraySizersi>0DebugMode
PrintSELL:RSIsurvenduDoubleToStringrsi[02maisEMAM5confirme;


4Sionestencorrectionnepastraderattendrequelacorrectionsetermine
ifisCorrection

ifDebugMode
PrintTradeEnumToStringorderTyperejet:CorrectiondtecteAttendreentredanszonesanscorrection;
returnfalse;


5Vrificationsupplmentaire:leprixdoittreprocheduborddelazonemeilleureentre
PourBUY:prfrerentrerprsdubasdelazone
PourSELL:prfrerentrerprsduhautdelazone
iforderType==ORDERTYPEBUYgaiBuyZoneLow>0gaiBuyZoneHigh>0

doublezoneRange=gaiBuyZoneHighgaiBuyZoneLow;
doubledistanceFromLow=currentPricegaiBuyZoneLow;

Sileprixestdansletierssuprieurdelazonecestmoinsoptimalmaisacceptable
ifdistanceFromLow>zoneRange07DebugMode
PrintBUY:PrixdansletierssuprieurdelazoneDoubleToStringdistanceFromLowzoneRange1001;

elseiforderType==ORDERTYPESELLgaiSellZoneLow>0gaiSellZoneHigh>0

doublezoneRange=gaiSellZoneHighgaiSellZoneLow;
doubledistanceFromHigh=gaiSellZoneHighcurrentPrice;

Sileprixestdansletiersinfrieurdelazonecestmoinsoptimalmaisacceptable
ifdistanceFromHigh>zoneRange07DebugMode
PrintSELL:PrixdansletiersinfrieurdelazoneDoubleToStringdistanceFromHighzoneRange1001;


Touteslesconditionssontremplies
ifDebugMode

stringrsiInfo=ArraySizersi>0?RSI=DoubleToStringrsi[01:;
PrintEnumToStringorderTypeconfirm:PrixdanszoneIAEntredepuisbonnedirectionEMAM5confirmPasdecorrectionrsiInfo;


returntrue;



MISEJOURDETOUSLESENDPOINTSRENDER

voidUpdateAllEndpoints

ifUseAllEndpointsreturn;

staticdatetimelastUpdate=0;
ifTimeCurrentlastUpdate<120Augment120secondespourmoinsdecharge
return;

lastUpdate=TimeCurrent;

stringanalysis=UpdateAnalysisEndpoint;
ifanalysis=
glastAnalysisData=analysis;

stringtrend=UpdateTrendEndpoint;
iftrend=
glastTrendData=trend;

stringprediction=UpdatePredictionEndpoint;
ifprediction=
glastPredictionData=prediction;

stringcoherent=UpdateCoherentEndpoint;
ifcoherent=
glastCoherentData=coherent;

PrintTouslesendpointsonttmisjour;



MISEJOURDELENDPOINTDANALYSE

stringUpdateAnalysisEndpoint

stringurl=AIAnalysisURL;
stringheaders=ContentType:applicationjson\r\n;
stringresult=;
ucharresultdata[;
stringresultheaders;

ucharemptydata[;
intresponseCode=WebRequestGETurlheaders5000emptydataresultdataresultheaders;

ifresponseCode==200

result=CharArrayToStringresultdata;
PrintAnalysisendpointmisjour:result;

elseifresponseCode==422

stringdata=\symbol\:\Symbol\;
ucharpostuchar[;
StringToCharArraydatapostuchar;

responseCode=WebRequestPOSTurlheaders5000postucharresultdataresultheaders;
ifresponseCode==200

result=CharArrayToStringresultdata;
PrintAnalysisendpointmisjourPOST:result;

else
PrintErreurAnalysisendpointGET:responseCodePOST:responseCode;

else
PrintErreurlorsdelamisejourdelanalysisendpointCode:responseCode;

returnresult;



MISEJOURDELENDPOINTDETENDANCE

stringUpdateTrendEndpoint

stringurl=TrendAPIURL;
stringheaders=ContentType:applicationjson\r\n;
stringresult=;
ucharresultdata[;
stringresultheaders;

ucharemptydata[;
intresponseCode=WebRequestGETurlheaders5000emptydataresultdataresultheaders;

ifresponseCode==200

result=CharArrayToStringresultdata;
PrintTrendendpointmisjour:result;

elseifresponseCode==422

stringdata=\symbol\:\Symbol\;
ucharpostuchar[;
StringToCharArraydatapostuchar;

responseCode=WebRequestPOSTurlheaders5000postucharresultdataresultheaders;
ifresponseCode==200

result=CharArrayToStringresultdata;
PrintTrendendpointmisjourPOST:result;

else
PrintErreurTrendendpointGET:responseCodePOST:responseCode;

else
PrintErreurlorsdelamisejourdutrendendpointCode:responseCode;

returnresult;



MISEJOURDELENDPOINTDEPRDICTION

stringUpdatePredictionEndpoint

stringurl=AIPredictSymbolURLSymbol;
ifDebugMode
PrintDEBUGAppelendpointprdiction:url;

stringheaders=ContentType:applicationjson\r\n;
stringresult=;
ucharresultdata[;
stringresultheaders;

ucharemptydata[;
intresponseCode=WebRequestGETurlheaders5000emptydataresultdataresultheaders;

ifresponseCode==200

result=CharArrayToStringresultdata;
PrintPredictionendpointmisjour:result;
ifDebugMode
PrintDEBUGDonnesbrutesreues:result;

elseifresponseCode==422responseCode==404

stringpostData=\symbol\:\Symbol\;
ucharpostuchar[;
StringToCharArraypostDatapostuchar;

responseCode=WebRequestPOSTurlheaders5000postucharresultdataresultheaders;
ifresponseCode==200

result=CharArrayToStringresultdata;
PrintPredictionendpointmisjourPOST:result;
ifDebugMode
PrintDEBUGDonnesbrutesreuesPOST:result;

else

PrintErreurPredictionendpointGET:responseCodePOST:responseCode;
ifDebugMode
PrintDEBUGchecGETPOSTpour:url;


else

PrintErreurlorsdelamisejourdupredictionendpointCode:responseCode;
ifDebugMode
PrintDEBUGErreurHTTPpour:urlCode:responseCode;


returnresult;



MISEJOURDELENDPOINTDANALYSECOHRENTE

stringUpdateCoherentEndpoint

stringurl=AICoherentAnalysisURL;
stringheaders=ContentType:applicationjson\r\n;
stringresult=;
ucharresultdata[;
stringresultheaders;

ucharemptydata[;
intresponseCode=WebRequestGETurlheaders5000emptydataresultdataresultheaders;

ifresponseCode==200

result=CharArrayToStringresultdata;
PrintCoherentendpointmisjour:result;

elseifresponseCode==422

stringdata=\symbol\:\Symbol\;
ucharpostuchar[;
StringToCharArraydatapostuchar;

responseCode=WebRequestPOSTurlheaders5000postucharresultdataresultheaders;
ifresponseCode==200

result=CharArrayToStringresultdata;
PrintCoherentendpointmisjourPOST:result;

else
PrintErreurCoherentendpointGET:responseCodePOST:responseCode;

else
PrintErreurlorsdelamisejourducoherentendpointCode:responseCode;

returnresult;



VRIFIERLALIGNEMENTDETOUSLESENDPOINTS

boolCheckAllEndpointsAlignmentENUMORDERTYPEorderType

ToujoursmettrejourletableaudebordmmesiRequireAllEndpointsAlignmentestfalse

Analyserlesdonnesdechaqueendpointpourvrifierlalignement
boolanalysisAligned=false;
booltrendAligned=false;
boolpredictionAligned=false;
boolcoherentAligned=false;

Analyseendpoint
ifglastAnalysisData=

stringupperData=glastAnalysisData;
StringToUpperupperData;
iforderType==ORDERTYPEBUYStringFindupperDataBUY>=0StringFindupperDataACHAT>=0
analysisAligned=true;
elseiforderType==ORDERTYPESELLStringFindupperDataSELL>=0StringFindupperDataVENTE>=0
analysisAligned=true;


Trendendpoint
ifglastTrendData=

stringupperData=glastTrendData;
StringToUpperupperData;
iforderType==ORDERTYPEBUYStringFindupperDataBUY>=0StringFindupperDataACHAT>=0
trendAligned=true;
elseiforderType==ORDERTYPESELLStringFindupperDataSELL>=0StringFindupperDataVENTE>=0
trendAligned=true;


Predictionendpoint
ifglastPredictionData=

stringupperData=glastPredictionData;
StringToUpperupperData;
iforderType==ORDERTYPEBUYStringFindupperDataBUY>=0StringFindupperDataACHAT>=0
predictionAligned=true;
elseiforderType==ORDERTYPESELLStringFindupperDataSELL>=0StringFindupperDataVENTE>=0
predictionAligned=true;


Coherentendpoint
ifglastCoherentData=

stringupperData=glastCoherentData;
StringToUpperupperData;
iforderType==ORDERTYPEBUYStringFindupperDataBUY>=0StringFindupperDataACHAT>=0
coherentAligned=true;
elseiforderType==ORDERTYPESELLStringFindupperDataSELL>=0StringFindupperDataVENTE>=0
coherentAligned=true;


Calculerlescoredalignement
intalignedCount=0;
ifanalysisAlignedalignedCount;
iftrendAlignedalignedCount;
ifpredictionAlignedalignedCount;
ifcoherentAlignedalignedCount;

gendpointsAlignment=doublealignedCount40;

Mettrejourlestatspourletableaudebord
galignmentStatus[0=analysisAligned?:;
galignmentStatus[1=trendAligned?:;
galignmentStatus[2=predictionAligned?:;
galignmentStatus[3=coherentAligned?:;

galignmentColors[0=analysisAligned?clrLime:clrRed;
galignmentColors[1=trendAligned?clrLime:clrRed;
galignmentColors[2=predictionAligned?clrLime:clrRed;
galignmentColors[3=coherentAligned?clrLime:clrRed;

Mettrejourletableaudebord
UpdateAlignmentDashboard;

boolallAligned=alignedCount>=3;Aumoins34endpointsaligns

ifDebugMode

PrintAlignementendpoints:alignedCount4alignsDoubleToStringgendpointsAlignment1001;
PrintAnalyse:analysisAligned?:glastAnalysisData;
PrintTrend:trendAligned?:glastTrendData;
PrintPrediction:predictionAligned?:glastPredictionData;
PrintCoherent:coherentAligned?:glastCoherentData;
PrintRsultat:allAligned?ALIGN:PASALIGN;


SiRequireAllEndpointsAlignmentestfalseretournertruepournepasbloquerlestrades
ifRequireAllEndpointsAlignment
returntrue;

returnallAligned;



Vrifiersiuneentreprometteuseavecrebondestprsente

boolCheckForPromisingEntryENUMORDERTYPEsignalType

Obtenirlesdonnesdeprix
doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doubleaskPrice=SymbolInfoDoubleSymbolSYMBOLASK;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

Obtenirlesdonneshistoriquespouranalyse
doubleclose[3high[3low[3;
ifCopyCloseSymbolPERIODM103close<3
CopyHighSymbolPERIODM103high<3
CopyLowSymbolPERIODM103low<3

ifDebugMode
PrintErreurrcuprationdonnesprixpourentreprometteuse;
returnfalse;


ObtenirlesEMApourdtectionderebond
doubleemaFast[3emaSlow[3;
ifCopyBufferemaFastHandle003emaFast<3
CopyBufferemaSlowHandle003emaSlow<3

ifDebugMode
PrintErreurrcuprationEMApourentreprometteuse;
returnfalse;


DTECTIONDEREBONDPOURSIGNALBUY
ifsignalType==ORDERTYPEBUY

1RebondsurEMAFastsupport
boolnearEMAFast=currentPrice>=emaFast[010pointcurrentPrice<=emaFast[010point;
boolwasBelowEMA=close[1<emaFast[1low[1<emaFast[1;
boolisBouncing=close[0>close[1high[0>emaFast[0;

ifnearEMAFastwasBelowEMAisBouncing

ifDebugMode
PrintEntreBUYprometteuse:RebondsurEMAFastdtect;
returntrue;


2RebondsurEMASlowsupportplusfort
boolnearEMASlow=currentPrice>=emaSlow[015pointcurrentPrice<=emaSlow[015point;
boolwasBelowSlow=close[1<emaSlow[1low[1<emaSlow[1;
boolisBouncingSlow=close[0>close[1high[0>emaSlow[0;

ifnearEMASlowwasBelowSlowisBouncingSlow

ifDebugMode
PrintEntreBUYprometteuse:RebondsurEMASlowdtect;
returntrue;


3PrixdanszoneIAetrebond
ifgaiBuyZoneLow>0gaiBuyZoneHigh>0

boolinZone=currentPrice>=gaiBuyZoneLowcurrentPrice<=gaiBuyZoneHigh;
boolwasLower=low[1<gaiBuyZoneLowclose[1<gaiBuyZoneLow;
boolisRecovering=close[0>close[1close[0>gaiBuyZoneLow;

ifinZonewasLowerisRecovering

ifDebugMode
PrintEntreBUYprometteuse:RebonddanszoneIAdtect;
returntrue;




DTECTIONDEREBONDPOURSIGNALSELL
elseifsignalType==ORDERTYPESELL

1RebondsurEMAFastrsistance
boolnearEMAFast=currentPrice>=emaFast[010pointcurrentPrice<=emaFast[010point;
boolwasAboveEMA=close[1>emaFast[1high[1>emaFast[1;
boolisRebounding=close[0<close[1low[0<emaFast[0;

ifnearEMAFastwasAboveEMAisRebounding

ifDebugMode
PrintEntreSELLprometteuse:RebondsurEMAFastdtect;
returntrue;


2RebondsurEMASlowrsistanceplusforte
boolnearEMASlow=currentPrice>=emaSlow[015pointcurrentPrice<=emaSlow[015point;
boolwasAboveSlow=close[1>emaSlow[1high[1>emaSlow[1;
boolisReboundingSlow=close[0<close[1low[0<emaSlow[0;

ifnearEMASlowwasAboveSlowisReboundingSlow

ifDebugMode
PrintEntreSELLprometteuse:RebondsurEMASlowdtect;
returntrue;


3PrixdanszoneIAetrebond
ifgaiSellZoneLow>0gaiSellZoneHigh>0

boolinZone=currentPrice>=gaiSellZoneLowcurrentPrice<=gaiSellZoneHigh;
boolwasHigher=high[1>gaiSellZoneHighclose[1>gaiSellZoneHigh;
boolisRecovering=close[0<close[1close[0<gaiSellZoneHigh;

ifinZonewasHigherisRecovering

ifDebugMode
PrintEntreSELLprometteuse:RebonddanszoneIAdtect;
returntrue;




ifDebugMode
PrintPasdentreprometteusedtectepourEnumToStringsignalType;

returnfalse;



ExcuteletradeavecSLTPdynamiquesselonletypedentre

voidExecuteTradeENUMORDERTYPEsignalType

doublecurrentPrice=SymbolInfoDoubleSymbolsignalType==ORDERTYPEBUY?SYMBOLASK:SYMBOLBID;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;
doublestopLoss=00;
doubletakeProfit=00;

ObtenirlesEMApourcalculerSLTPdynamiques
doubleemaFast[1emaSlow[1;
boolhasEMA=CopyBufferemaFastHandle001emaFast>0
CopyBufferemaSlowHandle001emaSlow>0;

CalculerSLTPselonletypedesignaletlecontexte
ifsignalType==ORDERTYPEBUY

SL:Justeendessousdusupportleplusproche
ifhasEMA

UtiliserlEMAlaplusbassecommesupport
doublesupportLevel=MathMinemaFast[0emaSlow[0;
stopLoss=supportLevel20point;Margedescurit

else

Fallback:SLbassurunpourcentageduprix
stopLoss=currentPriceStopLossUSDInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;


TP:Ratiorisquercompensede1:2ou1:3
doubleriskAmount=currentPricestopLoss;
takeProfit=currentPriceriskAmount25;Ratio1:25

VrifierqueleTPnestpastropprocheminimum2
doublepotentialProfit=takeProfitcurrentPriceInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
ifpotentialProfit<20
takeProfit=currentPrice20InitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

elseSELL

SL:Justeaudessusdelarsistancelaplusproche
ifhasEMA

UtiliserlEMAlaplushautecommersistance
doubleresistanceLevel=MathMaxemaFast[0emaSlow[0;
stopLoss=resistanceLevel20point;Margedescurit

else

Fallback:SLbassurunpourcentageduprix
stopLoss=currentPriceStopLossUSDInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;


TP:Ratiorisquercompensede1:2ou1:3
doubleriskAmount=stopLosscurrentPrice;
takeProfit=currentPriceriskAmount25;Ratio1:25

VrifierqueleTPnestpastropprocheminimum2
doublepotentialProfit=currentPricetakeProfitInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
ifpotentialProfit<20
takeProfit=currentPrice20InitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;


Normaliserlesprix
stopLoss=NormalizeDoublestopLossDigits;
takeProfit=NormalizeDoubletakeProfitDigits;

Vrifierlesniveauxminimumsdubroker
longstopLevel=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=stopLevelpoint;
ifminDistance==0
minDistance=10point;

AjusterSLTPsitropproches
ifsignalType==ORDERTYPEBUY

ifstopLoss>currentPriceminDistance
stopLoss=currentPriceminDistance;
iftakeProfit<currentPriceminDistance
takeProfit=currentPriceminDistance;

else

ifstopLoss<currentPriceminDistance
stopLoss=currentPriceminDistance;
iftakeProfit>currentPriceminDistance
takeProfit=currentPriceminDistance;


Excuterlordre
iftradePositionOpenSymbolsignalTypeInitialLotSizecurrentPricestopLosstakeProfitAISignalReboundEntry

stringsignalStr=signalType==ORDERTYPEBUY?BUY:SELL;
doubleriskUSD=MathAbscurrentPricestopLossInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=MathAbstakeProfitcurrentPriceInitialLotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintORDREEXCUT:signalStr@DoubleToStringcurrentPriceDigits;
PrintSL:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTP:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;

Envoyernotificationdexcution
stringexecText=ORDREEXCUT:signalStr
\nEntre:DoubleToStringcurrentPriceDigits
\nSL:DoubleToStringstopLossDigitsDoubleToStringriskUSD2
\nTP:DoubleToStringtakeProfitDigitsDoubleToStringrewardUSD2
\nRatio:1:DoubleToStringrewardUSDriskUSD1;

SendNotificationexecText;

else

PrintErreurexcutionordre:tradeResultRetcodetradeResultRetcodeDescription;




DTECTERPATTERNSDYNAMIQUESETLANCERTRADESLIMITS
Analyselespatternsdeprixsupportsrsistances
LancedestradesviaordreslimitsavecSLintelligent

boolDetectDynamicPatternsAndExecute

Rcuprerlesdonnesdeprixrcents
doubleclose[high[low[;
datetimetime[;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;
ArraySetAsSeriestimetrue;

ifCopyCloseSymbolPERIODM1050close<50
CopyHighSymbolPERIODM1050high<50
CopyLowSymbolPERIODM1050low<50
CopyTimeSymbolPERIODM1050time<50

ifDebugMode
PrintErreurrcuprationdonnesprixpourpatterndetection;
returnfalse;


doublecurrentPrice=close[0;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

Dtecterlespatternsdynamiques
1SupportRsistancedynamiquebassurlesswingsrcents
doublerecentHigh=0recentLow=DBLMAX;
forinti=1;i<20;i

ifhigh[i>recentHighrecentHigh=high[i;
iflow[i<recentLowrecentLow=low[i;


2Tendanceactuellebasesurles20derniresbougies
doubletrendSlope=0;
forinti=0;i<19;i

trendSlope=close[iclose[i1;

trendSlope=190;

3Momentumetvolatilit
doublemomentum=close[0close[9close[9;Momentum10bougies
doublevolatility=0;
forinti=0;i<19;i

doublediff=close[iclose[i1;
volatility=diffdiff;

volatility=MathSqrtvolatility190currentPrice;

Dtecterlespatternsdetrading
boolpatternDetected=false;
ENUMORDERTYPEsignalType=WRONGVALUE;
doubleentryPrice=0stopLoss=0takeProfit=0;
stringpatternName=;

PATTERN1:Reboundsursupportdynamiqueentendancehaussire
iftrendSlope>0momentum>0001
currentPrice>recentLowcurrentPrice<recentLow1002Prochedusupport

signalType=ORDERTYPEBUY;
entryPrice=recentLowpoint5;Ordrelimitjusteaudessusdusupport
stopLoss=recentLowpoint10;SLsouslesupport
takeProfit=currentPricecurrentPricestopLoss20;RR1:2
patternName=ReboundSupportDynamique;
patternDetected=true;


PATTERN2:Rejetsurrsistancedynamiqueentendancebaissire
elseiftrendSlope<0momentum<0001
currentPrice<recentHighcurrentPrice>recentHigh0998Prochedelarsistance

signalType=ORDERTYPESELL;
entryPrice=recentHighpoint5;Ordrelimitjustesouslarsistance
stopLoss=recentHighpoint10;SLaudessusdelarsistance
takeProfit=currentPricestopLosscurrentPrice20;RR1:2
patternName=RejetRsistanceDynamique;
patternDetected=true;


PATTERN3:Breakoutdeconsolidation
doublerange=recentHighrecentLow;
ifrange<currentPrice0002Consolidationtroite
MathAbsmomentum>0002Momentumfort

ifcurrentPrice>recentHigh1001Breakouthaussier

signalType=ORDERTYPEBUY;
entryPrice=recentHighpoint2;Ordrelimitaprsbreakout
stopLoss=recentLowpoint5;
takeProfit=entryPriceentryPricestopLoss15;
patternName=BreakoutHaussier;
patternDetected=true;

elseifcurrentPrice<recentLow0999Breakoutbaissier

signalType=ORDERTYPESELL;
entryPrice=recentLowpoint2;Ordrelimitaprsbreakout
stopLoss=recentHighpoint5;
takeProfit=entryPricestopLossentryPrice15;
patternName=BreakoutBaissier;
patternDetected=true;



ifpatternDetectedsignalType=WRONGVALUE

Calculerlatailledeposition
doublelotSize=NormalizeLotSizeInitialLotSize;

Validationdesdistancesminimales
doubleminDistance=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVELPoint;
doubleslDistance=MathAbsentryPricestopLoss;
doubletpDistance=MathAbstakeProfitentryPrice;

ifslDistance<minDistancetpDistance<minDistance

ifDebugMode
PrintPatterndtectmaisdistancesSLTPtropfaibles:patternName;
returnfalse;


RGLEBOOMCRASH:pasdeBUYsurCrashpasdeSELLsurBoom
ifStringFindSymbolCrash>=0signalType==ORDERTYPEBUYreturnfalse;
ifStringFindSymbolBoom>=0signalType==ORDERTYPESELLreturnfalse;

Excuterlordrelimit
iftradePositionOpenSymbolsignalTypelotSizeentryPricestopLosstakeProfitPattern:patternName

stringsignalStr=signalType==ORDERTYPEBUY?BUY:SELL;
doubleriskUSD=MathAbsentryPricestopLosslotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=MathAbstakeProfitentryPricelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintPATTERNDTECT:patternName;
PrintSignal:signalStr@DoubleToStringentryPriceDigits;
PrintSL:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTP:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintTendance:trendSlope>0?Haussire:BaissireMomentum:DoubleToStringmomentum1003;
PrintVolatilit:DoubleToStringvolatility1002RR:1:DoubleToStringrewardUSDriskUSD1;

Activerletrailingstopautomatiquement
ActivateTrailingStop;

Envoyernotification
stringpatternText=PATTERNDTECT:patternName
\nsignalStr@DoubleToStringentryPriceDigits
\nSL:DoubleToStringstopLossDigitsDoubleToStringriskUSD2
\nTP:DoubleToStringtakeProfitDigitsDoubleToStringrewardUSD2
\nRR:1:DoubleToStringrewardUSDriskUSD1
\nTrailingStop:ACTIV;

SendNotificationpatternText;
returntrue;

else

PrintErreurexcutionordrepattern:tradeResultRetcodetradeResultRetcodeDescription;



returnfalse;



Activerletrailingstoppourtouteslespositions

voidActivateTrailingStop

inttotal=PositionsTotal;
forinti=total1;i>=0;i

ifPositionSelectByTicketPositionGetTicketi

ulongticket=PositionGetIntegerPOSITIONTICKET;
doublecurrentPrice=PositionGetDoublePOSITIONPRICEOPEN;
doublecurrentSL=PositionGetDoublePOSITIONSL;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

TrailingstopdynamiquebassurlATR
doubleatr[;
ArraySetAsSeriesatrtrue;
ifCopyBufferatrHandle001atr>0atr[0>0

doubletrailingDistance=atr[020;2xATR

ifPositionGetIntegerPOSITIONTYPE==POSITIONTYPEBUY

doublenewSL=SymbolInfoDoubleSymbolSYMBOLBIDtrailingDistance;
ifnewSL>currentSLpoint10DplacerleSLseulementsifavorable

tradePositionModifyticketnewSLPositionGetDoublePOSITIONTP;
ifDebugMode
PrintTrailingBUY:SLdplacDoubleToStringnewSLDigits;


elseSELL

doublenewSL=SymbolInfoDoubleSymbolSYMBOLASKtrailingDistance;
ifnewSL<currentSLpoint10DplacerleSLseulementsifavorable

tradePositionModifyticketnewSLPositionGetDoublePOSITIONTP;
ifDebugMode
PrintTrailingSELL:SLdplacDoubleToStringnewSLDigits;








Placerordrelimitdslapparitiondelaflche
Utiliselessupportsrsistancespourdterminerleprixdentre

boolPlaceLimitOrderOnArrowENUMORDERTYPEsignalType

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doubleaskPrice=SymbolInfoDoubleSymbolSYMBOLASK;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

ifDebugMode

PrintDBUTPLACEMENTORDRELIMIT;
PrintSignal:EnumToStringsignalType;
PrintPrixactuel:DoubleToStringcurrentPriceDigits;
PrintAsk:DoubleToStringaskPriceDigits;
PrintConfianceIA:DoubleToStringglastAIConfidence1001;
PrintActionIA:glastAIAction;


Vrifiersionadjunepositionouunordresurcesymbole
inttotalOrders=OrdersTotal;
forinti=totalOrders1;i>=0;i

iforderInfoSelectByIndexi

iforderInfoSymbol==SymbolorderInfoMagic==InpMagicNumber

ifDebugMode
PrintOrdredjexistentsurSymboltype:EnumToStringorderInfoOrderType;
returnfalse;




inttotalPositions=PositionsTotal;
forinti=totalPositions1;i>=0;i

ifpositionInfoSelectByIndexi

ifpositionInfoSymbol==SymbolpositionInfoMagic==InpMagicNumber

ifDebugMode
PrintPositiondjexistantesurSymboltype:EnumToStringpositionInfoPositionType;
returnfalse;




Rcuprerlessupportsrsistancesactuels
doubleatrM1[atrM5[atrH1[;
ArraySetAsSeriesatrM1true;
ArraySetAsSeriesatrM5true;
ArraySetAsSeriesatrH1true;

ifCopyBufferatrM1Handle001atrM1<=0
CopyBufferatrM5Handle001atrM5<=0
CopyBufferatrH1Handle001atrH1<=0

ifDebugMode
PrintImpossibledercuprerATRpourordrelimit;
returnfalse;


ANALYSEDESBOUGIESPRDITESsidisponible
doublepredictedDip=00;
doublepredictedPeak=00;
boolusePrediction=false;

Vrifiersilaprdictionestfrache<2minutesetsionadesdonnes
doublepredConfLocal=00;Confiancelocaledelaprdiction

ifglastPredictionData=TimeCurrentglastAITime<120

stringpredDir=;
ifParsePredictionDataglastPredictionDatapredDirpredConfLocal

Convertirdirectionunifie
ifpredDir==UPpredDir=buy;
ifpredDir==DOWNpredDir=sell;

Silaprdictionestcontraireausignalonannule
ifsignalType==ORDERTYPEBUYpredDir==sell

ifDebugModePrintSignalBUYmaisPrdictionSELLAnnulationordrelimit;
returnfalse;

ifsignalType==ORDERTYPESELLpredDir==buy

ifDebugModePrintSignalSELLmaisPrdictionBUYAnnulationordrelimit;
returnfalse;


usePrediction=true;
ifDebugModePrintPrdictionaligneaveclesignalConf:DoubleToStringpredConfLocal1001Optimisation;



Calculerlesniveauxdesupportrsistance
doublesupportM1=currentPrice15atrM1[0;
doubleresistanceM1=currentPrice15atrM1[0;
doublesupportM5=currentPrice20atrM5[0;
doubleresistanceM5=currentPrice20atrM5[0;
doublesupportH1=currentPrice25atrH1[0;
doubleresistanceH1=currentPrice25atrH1[0;

ifDebugMode

PrintNIVEAUXCALCULS:;
PrintSupportM1:DoubleToStringsupportM1Digits;
PrintRsistanceM1:DoubleToStringresistanceM1Digits;
PrintSupportM5:DoubleToStringsupportM5Digits;
PrintRsistanceM5:DoubleToStringresistanceM5Digits;
PrintSupportH1:DoubleToStringsupportH1Digits;
PrintRsistanceH1:DoubleToStringresistanceH1Digits;


doubleentryPrice=0;
doublestopLoss=0;
doubletakeProfit=0;
stringorderReason=;

ifsignalType==ORDERTYPEBUY

OrdreBUYLIMIT:Placersousleprixactuelprsdunsupport
Trouverlesupportleplusprocheendessousduprix
doublenearestSupport=0;
stringsupportType=;

Logiqueexistanteprioritairesurlessupports
ifsupportM1<currentPricenearestSupport==0supportM1>nearestSupportnearestSupport=supportM1;supportType=SupportM1;
ifsupportM5<currentPricenearestSupport==0supportM5>nearestSupportnearestSupport=supportM5;supportType=SupportM5;
ifsupportH1<currentPricenearestSupport==0supportH1>nearestSupportnearestSupport=supportH1;supportType=SupportH1;

OPTIMISATIONPRDICTION:Sionauneprdictionessayerdentrerencoreplusbassipossible
ifusePrediction

UtiliserlaconfiancedelaPRDICTIONpaslaglobale
doubleconfidenceToUse=predConfLocal>0?predConfLocal:glastAIConfidence;

Silaprdictionesttrsconfiante>80onpeuttreplusagressifentreplusproche
ifconfidenceToUse>080

Entreunpeuplushautepournepasraterletrain
ifnearestSupport>0nearestSupport=atrM1[002;

else

Attendrerepli
ifnearestSupport>0nearestSupport=atrM1[002;



ifnearestSupport>0

PlacerlordreBUYLIMITjusteaudessusdusupportleplusproche
entryPrice=nearestSupportpointLimitEntryOffsetPoints;
stopLoss=nearestSupportpointLimitSLOffsetPoints;
takeProfit=entryPriceentryPricestopLossLimitRR;
orderReason=supportTypeusePrediction?IA:;

ifDebugMode
PrintBUYLIMITplacaudessusdesupportType@DoubleToStringnearestSupportDigits;

else

Aucunsupportendessousduprixutilisersupportcalcul
nearestSupport=currentPrice20atrM5[0;
entryPrice=nearestSupportpointLimitEntryOffsetPoints;
stopLoss=nearestSupportpointLimitSLOffsetPoints;
takeProfit=entryPriceentryPricestopLossLimitRR;
orderReason=Supportcalcul;

ifDebugMode
PrintAucunsupportendessousutilisationsupportcalcul@DoubleToStringnearestSupportDigits;


elseSELL

OrdreSELLLIMIT:Placeraudessusduprixactuelprsdunersistance
doublenearestResistance=0;
stringresistanceType=;

ifresistanceM1>currentPricenearestResistance==0resistanceM1<nearestResistancenearestResistance=resistanceM1;resistanceType=RsistanceM1;
ifresistanceM5>currentPricenearestResistance==0resistanceM5<nearestResistancenearestResistance=resistanceM5;resistanceType=RsistanceM5;
ifresistanceH1>currentPricenearestResistance==0resistanceH1<nearestResistancenearestResistance=resistanceH1;resistanceType=RsistanceH1;

OPTIMISATIONPRDICTION
ifusePrediction

UtiliserlaconfiancedelaPRDICTIONpaslaglobale
doubleconfidenceToUse=predConfLocal>0?predConfLocal:glastAIConfidence;

ifconfidenceToUse>080

Entreplusbasseplusprocheduprixactuelpournepasrater
ifnearestResistance>0nearestResistance=atrM1[002;

else

Attendrerebondplushaut
ifnearestResistance>0nearestResistance=atrM1[002;



ifnearestResistance>0

PlacerlordreSELLLIMITjustesouslarsistancelaplusproche
entryPrice=nearestResistancepointLimitEntryOffsetPoints;
stopLoss=nearestResistancepointLimitSLOffsetPoints;
takeProfit=entryPricestopLossentryPriceLimitRR;
orderReason=resistanceTypeusePrediction?IA:;

ifDebugMode
PrintSELLLIMITplacsousresistanceType@DoubleToStringnearestResistanceDigits;

else

Aucunersistanceaudessusduprixutiliserrsistancecalcule
nearestResistance=currentPrice20atrM5[0;
entryPrice=nearestResistancepointLimitEntryOffsetPoints;
stopLoss=nearestResistancepointLimitSLOffsetPoints;
takeProfit=entryPricestopLossentryPriceLimitRR;
orderReason=Rsistancecalcule;

ifDebugMode
PrintAucunersistanceaudessusutilisationrsistancecalcule@DoubleToStringnearestResistanceDigits;



TransformerBUYSELLentypependingBUYLIMITSELLLIMIT
ENUMORDERTYPEpendingType=GetPendingTypeFromSignalsignalType;
ifpendingType==WRONGVALUE
returnfalse;

Sanity:uneBUYLIMITdoittre<Ask;uneSELLLIMITdoittre>Bid
ifpendingType==ORDERTYPEBUYLIMITentryPrice>=askPrice2point
entryPrice=NormalizeDoubleaskPrice10pointDigits;
ifpendingType==ORDERTYPESELLLIMITentryPrice<=currentPrice2point
entryPrice=NormalizeDoublecurrentPrice10pointDigits;

AjusterSLTPpourrespecterlesdistancesminimalesbroker
ifEnsureStopsDistanceValidentryPricependingTypestopLosstakeProfit

ifDebugMode
PrintSLTPinvalidesaprsajustementAnnulationordreLIMIT;
returnfalse;


Calculerlatailledeposition
doublelotSize=NormalizeLotSizeInitialLotSize;

Pourdebug:recalculerdistancesSLTPetdistanceminimalerequise
doubleslDistance=MathAbsentryPricestopLoss;
doubletpDistance=MathAbstakeProfitentryPrice;
longdebugStopLevelPts=SymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL;
doubleminDistance=debugStopLevelPtspoint;
ifminDistance<5pointminDistance=5point;
ifIsDerivSyntheticIndexSymbol
minDistance=MathMaxminDistance15point;

ifDebugMode

PrintDTAILSORDRELIMIT:;
PrintType:EnumToStringsignalType;
PrintPrixdentre:DoubleToStringentryPriceDigits;
PrintStopLoss:DoubleToStringstopLossDigits;
PrintTakeProfit:DoubleToStringtakeProfitDigits;
PrintTaille:DoubleToStringlotSize2;
PrintRaison:orderReason;
PrintDistanceSL:DoubleToStringslDistancepoint0points;
PrintDistanceTP:DoubleToStringtpDistancepoint0points;
PrintDistanceminimalerequise:DoubleToStringminDistancepoint0points;


Normaliserlesprixavantenvoiaubroker
entryPrice=NormalizeDoubleentryPriceDigits;
stopLoss=NormalizeDoublestopLossDigits;
takeProfit=NormalizeDoubletakeProfitDigits;

Placerlordrelimit
stringorderComment=LimitOrderonArroworderReason;

ifDebugMode

PrintTENTATIVEPLACEMENTORDRELIMIT:;
PrintSymbol:Symbol;
PrintType:EnumToStringsignalType;
PrintLotSize:DoubleToStringlotSize2;
PrintEntryPrice:DoubleToStringentryPriceDigits;
PrintStopLoss:DoubleToStringstopLossDigits;
PrintTakeProfit:DoubleToStringtakeProfitDigits;
PrintOrderTime:ORDERTIMEGTC;
PrintExpiration:0;
PrintComment:orderComment;


IMPORTANT:utiliserletypePENDINGBUYLIMITSELLLIMITpasBUYSELLmarch
boolorderOk=false;
ifpendingType==ORDERTYPEBUYLIMIT
orderOk=tradeBuyLimitlotSizeentryPriceSymbolstopLosstakeProfitORDERTIMEGTC0orderComment;
elseifpendingType==ORDERTYPESELLLIMIT
orderOk=tradeSellLimitlotSizeentryPriceSymbolstopLosstakeProfitORDERTIMEGTC0orderComment;

iforderOk

doubleriskUSD=MathAbsentryPricestopLosslotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;
doublerewardUSD=MathAbstakeProfitentryPricelotSizeSymbolInfoDoubleSymbolSYMBOLTRADETICKVALUE;

PrintORDRELIMITPLAC:EnumToStringpendingType@DoubleToStringentryPriceDigits;
PrintRaison:orderReason;
PrintSL:DoubleToStringstopLossDigitsrisque:DoubleToStringriskUSD2;
PrintTP:DoubleToStringtakeProfitDigitsgain:DoubleToStringrewardUSD2;
PrintRatioRR:1:DoubleToStringrewardUSDriskUSD1;

Activerletrailingstoppourcetordre
ActivateTrailingStop;

returntrue;

else

PrintErreurplacementordrelimit:tradeResultRetcodetradeResultRetcodeDescription;
ifDebugMode

PrintDebugordrepending:;
PrintpendingType=EnumToStringpendingType
entry=DoubleToStringentryPriceDigits
SL=DoubleToStringstopLossDigits
TP=DoubleToStringtakeProfitDigits
stopsLevelPts=intSymbolInfoIntegerSymbolSYMBOLTRADESTOPSLEVEL
point=DoubleToStringpointDigits;

returnfalse;




Transactionhandler

voidOnTradeTransactionconstMqlTradeTransactiontrans
constMqlTradeRequestrequest
constMqlTradeResultresult

Checkiftransactionisadealaddclosedpositionornewentry
iftranstype==TRADETRANSACTIONDEALADD

ulongdealTicket=transdeal;
ifHistoryDealSelectdealTicket

longdealEntry=HistoryDealGetIntegerdealTicketDEALENTRY;

OnlyinterestedincloseddealsDEALENTRYOUTorDEALENTRYOUTBY
ifdealEntry==DEALENTRYOUTdealEntry==DEALENTRYOUTBY

longmagic=HistoryDealGetIntegerdealTicketDEALMAGIC;
stringsymbol=HistoryDealGetStringdealTicketDEALSYMBOL;

Filterbyourmagicnumberandsymbol
ifmagic==InpMagicNumbersymbol==Symbol

doubleprofit=HistoryDealGetDoubledealTicketDEALPROFIT;
doubleswap=HistoryDealGetDoubledealTicketDEALSWAP;
doublecommission=HistoryDealGetDoubledealTicketDEALCOMMISSION;
doubletotalNetProfit=profitswapcommission;

ENUMDEALTYPEtype=ENUMDEALTYPEHistoryDealGetIntegerdealTicketDEALTYPE;
stringaction=type==DEALTYPEBUY?buy:sell;ClosingaSELLisaBUYdealclosingaBUYisaSELLdeal
WaitforfeedbackwewanttheORIGINALdirection
ClosingaBUYpositioncreatesaSELLdealSoifdealisSELLoriginalwasBUY
Letsinferoriginaltype:
stringoriginalAction=type==DEALTYPESELL?buy:sell;

SendfeedbacktoRender
SendFeedbackToRendersymboloriginalActiontotalNetProfit;







SendtradefeedbacktoRenderserver

voidSendFeedbackToRenderstringsymbolstringactiondoubleprofit

ifUseAIAgentreturn;

ConstructJSONpayloadmanually
stringjson=;
json=\symbol\:\symbol\;
json=\action\:\action\;
json=\profit\:DoubleToStringprofit2;
json=\timestamp\:\TimeToStringTimeCurrentTIMEDATETIMEMINUTES\;
Includelastpredictiondataifavailabletocorrelate
ifglastPredictionData=

EscapequotesinnestedJSONifnecessaryorjustsendsubstring
Simpleapproach:justindicateifitmatched
boolmatched=false;
ifaction==buyStringFindglastPredictionData\direction\:\buy\>=0matched=true;
ifaction==sellStringFindglastPredictionData\direction\:\sell\>=0matched=true;
json=\predictionmatch\:matched?true:false;

else

json=\predictionmatch\:null;

json=;

chardata[;
StringToCharArrayjsondata0StringLenjsonCPUTF8;

stringheaders=ContentType:applicationjson\r\n;
charresdata[;
stringresheaders;

URLforfeedbackendpointassumedfeedbackbasedonbaseURL
stringurl=AITimeWindowsURLBasefeedback;

AsyncorSync?SyncissaferforsimplenetworkinginMT5butinsideOnTradeTransaction
weshouldbecarefulWebRequestISallowedinOnTradeTransaction?
ActuallyWebRequestisNOTforbiddeninOnTradeTransactionbutrecommendedtolikelyusevariablesorasync
GivenMT5limitationswelltrystandardWebRequestwithshorttimeout

inttimeout=1000;1secondtimeout
Correction:utiliserresdataetresheaderspourlarponse
intres=WebRequestPOSTurlheaderstimeoutdataresdataresheaders;

ifres=200

ifDebugModePrintCrationfeedbackchoueoutimeout:res;

else

ifDebugModePrintFeedbackenvoyRender:profitsursymbol;




Obtenirleseuildeconfiancerequisselonlesymbole

doubleGetRequiredConfidenceForSymbolstringsymbolboolcautiousMode

Modeprudent:seuilpluslev
ifcautiousMode

ifDebugModePrintDEBUG:ModeprudentactivretourneAIMinConfidenceCautious=AIMinConfidenceCautious;
returnAIMinConfidenceCautious;


Dterminerletypedesymbole
boolisVolatility=StringFindsymbolVolatility=1;
boolisBoom=StringFindsymbolBoom=1;
boolisCrash=StringFindsymbolCrash=1;
boolisStep=StringFindsymbolStep=1;
boolisForex=false;

ifDebugModePrintDEBUG:Symbolesymbol>Volatility:isVolatilityBoom:isBoomCrash:isCrashStep:isStep;

Vrifiersicestunepaireforexmajeure
stringforexPairs[=EURGBPUSDJPYAUDCADCHFNZD;
forinti=0;i<ArraySizeforexPairs;i

ifStringFindsymbolforexPairs[i=1

isForex=true;
break;



Appliquerlesseuilsselonletype
ifisBoomisCrashisVolatilityisStep

ifDebugModePrintDEBUG:SymboleVolatilityBoomCrashStepretourneAIMinConfidenceVolatility=AIMinConfidenceVolatility;
returnAIMinConfidenceVolatility;550

elseifisForex

ifDebugModePrintDEBUG:SymboleForexretourneAIMinConfidenceForex=AIMinConfidenceForex;
returnAIMinConfidenceForex;700

else

ifDebugModePrintDEBUG:SymbolepardfautretourneAIMinConfidenceDefault=AIMinConfidenceDefault;
returnAIMinConfidenceDefault;650




HelperpourparserlesdonnesdeprdictionJSON

boolParsePredictionDatastringjsonstringdirectiondoubleconfidence

ifjson==returnfalse;

direction=;
confidence=00;

Extrairedirection
intpredDirPos=StringFindjson\direction\;
ifpredDirPos>=0

intdirPos=StringFindjson\direction\predDirPos;
ifdirPos>=0

intcolonPos=StringFindjson:dirPos;
ifcolonPos>=0

intstart=colonPos1;
whilestart<StringLenjsonStringSubstrjsonstart1==start;
ifstart<StringLenjsonStringSubstrjsonstart1==\start;
intend=StringFindjson\start;
ifend>startdirection=StringSubstrjsonstartendstart;




Extraireconfiance
intconfPos=StringFindjson\confidence\predDirPos;
ifconfPos>=0

intcolonPos=StringFindjson:confPos;
ifcolonPos>=0

intstart=colonPos1;
whilestart<StringLenjsonStringSubstrjsonstart1==start;
ifstart<StringLenjsonStringSubstrjsonstart1==\start;Parfoisjsonnumbernapasdequotesmaisongre

intend=StringFindjsonstart;
ifend<0end=StringFindjsonstart;

ifend>start

stringconfStr=StringSubstrjsonstartendstart;
confidence=StringToDoubleconfStr;




returndirection=confidence>0;



NOUVELLESFONCTIONSDAMLIORATION



Dtecteretafficherlescorrectionsversrsistancessupports

voidDetectAndDisplayCorrections

VrifiersinousavonsunsignalIArcentSELLouBUY
ifglastAIAction==glastAIConfidence<070
return;PasdesignalIAfiablercent

doublecurrentPrice=SymbolInfoDoubleSymbolSYMBOLBID;
doublepoint=SymbolInfoDoubleSymbolSYMBOLPOINT;

Rcuprerlesdonnesdeprixrcents
doubleclose[high[low[;
datetimetime[;
ArraySetAsSeriesclosetrue;
ArraySetAsSerieshightrue;
ArraySetAsSerieslowtrue;
ArraySetAsSeriestimetrue;

ifCopyCloseSymbolPERIODM1020close<20
CopyHighSymbolPERIODM1020high<20
CopyLowSymbolPERIODM1020low<20
CopyTimeSymbolPERIODM1020time<20
return;

RcuprerlesATR
doubleatrM1[atrM5[atrH1[;
ArraySetAsSeriesatrM1true;
ArraySetAsSeriesatrM5true;
ArraySetAsSeriesatrH1true;

ifCopyBufferatrM1Handle001atrM1<=0
CopyBufferatrM5Handle001atrM5<=0
CopyBufferatrH1Handle001atrH1<=0
return;

Calculerlesniveaux
doubleresistanceM1=currentPrice15atrM1[0;
doubleresistanceM5=currentPrice20atrM5[0;
doubleresistanceH1=currentPrice25atrH1[0;
doublesupportM1=currentPrice15atrM1[0;
doublesupportM5=currentPrice20atrM5[0;
doublesupportH1=currentPrice25atrH1[0;

Dtecterlescorrections
boolisCorrectionToResistance=false;
boolisCorrectionToSupport=false;
stringtargetZone=;
doubletargetPrice=0;

ifStringCompareglastAIActionsell==0

SignalSELLconnucherchercorrectionversrsistance
Vrifiersileprixmonteaprsunebaissecorrectionhaussire
boolwasDropping=close[3>close[2close[2>close[1;Baissesur3priodes
boolisCorrectingUp=close[0>close[1close[1>close[2;Reprisesur2priodes

ifwasDroppingisCorrectingUp

Vrifierladistanceauxrsistances
doubledistToM1=resistanceM1currentPrice;
doubledistToM5=resistanceM5currentPrice;
doubledistToH1=resistanceH1currentPrice;

Siapprochedunersistancemoinsde1ATR
ifdistToM1<atrM1[0distToM1>0

isCorrectionToResistance=true;
targetZone=RsistanceM1;
targetPrice=resistanceM1;

elseifdistToM5<atrM5[0distToM5>0

isCorrectionToResistance=true;
targetZone=RsistanceM5;
targetPrice=resistanceM5;

elseifdistToH1<atrH1[0distToH1>0

isCorrectionToResistance=true;
targetZone=RsistanceH1;
targetPrice=resistanceH1;



elseifStringCompareglastAIActionbuy==0

SignalBUYconnucherchercorrectionverssupport
Vrifiersileprixbaisseaprsunehaussecorrectionbaissire
boolwasRising=close[3<close[2close[2<close[1;Haussesur3priodes
boolisCorrectingDown=close[0<close[1close[1<close[2;Baissesur2priodes

ifwasRisingisCorrectingDown

Vrifierladistanceauxsupports
doubledistToM1=currentPricesupportM1;
doubledistToM5=currentPricesupportM5;
doubledistToH1=currentPricesupportH1;

Siapprochedunsupportmoinsde1ATR
ifdistToM1<atrM1[0distToM1>0

isCorrectionToSupport=true;
targetZone=SupportM1;
targetPrice=supportM1;

elseifdistToM5<atrM5[0distToM5>0

isCorrectionToSupport=true;
targetZone=SupportM5;
targetPrice=supportM5;

elseifdistToH1<atrH1[0distToH1>0

isCorrectionToSupport=true;
targetZone=SupportH1;
targetPrice=supportH1;




Afficherlanotificationsurlegraphiquesicorrectiondtecte
ifisCorrectionToResistanceisCorrectionToSupporttargetPrice>0

stringcorrectionName=CORRECTIONNOTIFICATIONSymbol;
datetimecurrentTime=TimeCurrent;
datetimenotificationTime=currentTimePeriodSecondsPERIODM12;

Supprimerlanciennenotification
ObjectDelete0correctionName;

Crerlanouvellenotification
ifObjectCreate0correctionNameOBJTEXT0notificationTimetargetPrice

stringnotificationText=;
colornotificationColor=clrWhite;

ifisCorrectionToResistance

notificationText=CORRECTIONVERSRSISTANCE\n
SignalSELLIA:DoubleToStringglastAIConfidence1\n
Cible:targetZone@DoubleToStringtargetPriceDigits\n
EntreSELLLIMITpossible;
notificationColor=clrOrange;

elseifisCorrectionToSupport

notificationText=CORRECTIONVERSSUPPORT\n
SignalBUYIA:DoubleToStringglastAIConfidence1\n
Cible:targetZone@DoubleToStringtargetPriceDigits\n
EntreBUYLIMITpossible;
notificationColor=clrDodgerBlue;


ObjectSetString0correctionNameOBJPROPTEXTnotificationText;
ObjectSetInteger0correctionNameOBJPROPCOLORnotificationColor;
ObjectSetInteger0correctionNameOBJPROPFONTSIZE8;
ObjectSetString0correctionNameOBJPROPFONTArialBold;
ObjectSetInteger0correctionNameOBJPROPBACKfalse;
ObjectSetInteger0correctionNameOBJPROPANCHORANCHORLEFT;

Dessineruneflcheverslacible
stringarrowName=CORRECTIONARROWSymbol;
ObjectDelete0arrowName;

ifObjectCreate0arrowNameOBJARROW0notificationTimetargetPrice

ObjectSetInteger0arrowNameOBJPROPCOLORnotificationColor;
ObjectSetInteger0arrowNameOBJPROPSTYLESTYLESOLID;
ObjectSetInteger0arrowNameOBJPROPWIDTH2;
ObjectSetInteger0arrowNameOBJPROPARROWCODEisCorrectionToResistance?241:242;
ObjectSetInteger0arrowNameOBJPROPBACKfalse;


LogdansExperts
ifDebugMode

PrintCORRECTIONDTECTE:;
PrintSignalIA:StringToUpperglastAIActionconf:DoubleToStringglastAIConfidence1;
PrintType:isCorrectionToResistance?Versrsistance:Verssupport;
PrintZonecible:targetZone;
PrintPrixcible:DoubleToStringtargetPriceDigits;
PrintPrixactuel:DoubleToStringcurrentPriceDigits;
PrintDistance:DoubleToStringMathAbstargetPricecurrentPricepoint1pips;







